<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX & FIT Route Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #header {
            background: #1a73e8;
            color: white;
            padding: 12px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        #header h1 {
            font-size: 20px;
            font-weight: 500;
        }
        #mainContainer {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        #sidebar {
            width: 320px;
            background: #f8f9fa;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s ease;
            position: relative;
            z-index: 100;
        }
        #sidebar.collapsed {
            margin-left: -320px;
        }
        #sidebarToggle {
            position: absolute;
            right: -40px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            z-index: 101;
        }
        #sidebarToggle:hover {
            background: #1557b0;
        }
        #sidebarHeader {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
        }
        #sidebarHeader h2 {
            font-size: 16px;
            color: #333;
            margin-bottom: 10px;
        }
        #compareBtn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            width: 100%;
            transition: all 0.2s;
        }
        #compareBtn:hover {
            background: #1557b0;
        }
        #compareBtn.active {
            background: #34a853;
        }       
        #compactDropZone {
            border: 2px dashed #ccc;
            border-radius: 6px;
            padding: 12px 10px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.2s;
        }
        #compactDropZone.dragover {
            border-color: #1a73e8;
            background: #e8f0fe;
        }
        #compactDropZone p {
            color: #5f6368;
            font-size: 12px;
            margin: 0;
        }
        #compactDropZone input {
            display: none; 
        }

        #compactDropZone.hidden {
            display: none;
        }

        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px 20px;
            margin: 15px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        #dropZone.dragover {
            border-color: #1a73e8;
            background: #e8f0fe;
        }
        #dropZone p {
            color: #5f6368;
            font-size: 14px;
            margin-bottom: 8px;
        }
        #dropZone input {
            display: none;
        }
        #fileList {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #fileList::-webkit-scrollbar {
            width: 8px;
        }
        #fileList::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #fileList::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        #fileList::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .file-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }
        .file-item:hover {
            border-color: #1a73e8;
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.15);
        }
        .file-item.highlighted {
            border-color: #1a73e8;
            background: #e8f0fe;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.3);
        }
        .file-item.selected {
            border-color: #ffc107;
            background: #fff8e1;
        }
        .compare-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            display: none;
        }
        .compare-mode .compare-checkbox {
            display: block;
        }
        .file-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .file-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }
        .file-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #ddd;
            flex-shrink: 0;
        }
        .file-name-container {
            flex: 1;
            margin-bottom: 8px;
        }
        .file-display-name {
            font-size: 14px;
            font-weight: 600;
            padding: 4px 6px;
            border-radius: 4px;
            width: 100%;
            border: 1px solid transparent;
            background: #f8f9fa;
            word-wrap: break-word;
            min-height: 28px;
            display: flex;
            align-items: center;
        }
        .file-display-name:hover {
            border-color: #e0e0e0;
        }
        .file-display-name:focus {
            outline: none;
            border-color: #1a73e8;
            background: white;
        }
        .file-original-name {
            font-size: 10px;
            color: #666;
            padding: 2px 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .file-stats {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 6px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid #e8e8e8;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #666;
            font-weight: 500;
        }
        .stat-value {
            font-weight: 600;
            color: #1a73e8;
        }
        .elevation-chart-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            width: 100%;
            margin-bottom: 4px;
            font-weight: 500;
        }
        .elevation-chart-btn:hover {
            background: #1557b0;
        }
        .file-actions {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .file-play {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            flex: 1;
            font-weight: 500;
        }
        .file-play:hover {
            background: #1557b0;
        }
        .file-play.playing {
            background: #ea4335;
        }
        .file-toggle {
            background: #34a853;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            flex: 1;
            font-weight: 500;
        }
        .file-toggle.hidden-route {
            background: #999;
        }
        .file-toggle:hover {
            opacity: 0.8;
        }
        .file-remove {
            background: #ea4335;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            flex: 1;
            font-weight: 500;
        }
        .file-remove:hover {
            background: #d33828;
        }
        #mapContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        #map {
            flex: 1;
            width: 100%;
        }
        .hidden {
            display: none !important;
        }
        #routeTooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        #playbackControls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 150;
            display: none;
            align-items: center;
            gap: 10px;
        }
        #playbackControls.show {
            display: flex;
        }
        .speed-btn {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .speed-btn:hover {
            background: #e8f0fe;
            border-color: #1a73e8;
        }
        .speed-btn.active {
            background: #1a73e8;
            color: white;
            border-color: #1a73e8;
        }
        .speed-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        #comparisonPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 2px solid #1a73e8;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.15);
            z-index: 200;
            max-height: 50vh;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        #comparisonPanel.show {
            transform: translateY(0);
        }
        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
        }
        .comparison-header h3 {
            color: #1a73e8;
            font-size: 16px;
            font-weight: 600;
        }
        .comparison-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .comparison-elevation-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .comparison-elevation-btn:hover {
            background: #1557b0;
        }
        .comparison-elevation-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .comparison-close {
            background: #ea4335;
            color: white;
            border: none;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .comparison-close:hover {
            background: #d33828;
        }
        .comparison-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px 20px;
        }
        .comparison-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .comparison-content::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .comparison-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .comparison-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #5f6368;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .route-name-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .route-color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        #elevationModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        #elevationModal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 90%;
            width: 1000px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        .modal-header h2 {
            font-size: 18px;
            color: #1a73e8;
            font-weight: 600;
        }
        .modal-close {
            background: #ea4335;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        .modal-close:hover {
            background: #d33828;
        }
        #elevationChart {
            width: 100%;
            height: 400px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: crosshair;
        }
        #elevationChart.drag-mode {
            cursor: grab;
        }
        #elevationChart.dragging {
            cursor: grabbing;
        }
        .chart-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .chart-control-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .chart-control-btn:hover {
            background: #1557b0;
        }
        .chart-control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .chart-control-btn.active {
            background: #34a853;
        }
        .chart-legend {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .legend-item:hover {
            background: #e8f0fe;
        }
        .legend-item.active {
            background: #e8f0fe;
            box-shadow: 0 0 0 2px #1a73e8;
        }
        .legend-color {
            width: 30px;
            height: 3px;
            margin-right: 8px;
        }
        .legend-label {
            font-size: 13px;
            color: #333;
        }
        .legend-offset {
            font-size: 11px;
            color: #666;
            margin-left: 8px;
            font-style: italic;
        }

        #speedSlider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #e0e0e0 0%, #1a73e8 0%);
            outline: none;
        }

        #speedSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1a73e8;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #speedSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1a73e8;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>🗺️ GPX & FIT Route Overlay</h1>
    </div>

    <div id="mainContainer">
        <!-- Sidebar -->
        <div id="sidebar">
            <button id="sidebarToggle" title="Toggle sidebar">◀</button>
            
            <div id="sidebarHeader">
            <h2>📂 Routes</h2>
            <button id="compareBtn">📊 Compare Routes</button>
            <div id="compactDropZone" class="hidden">
                <p>➕ Add more routes</p>
                <input type="file" id="compactFileInput" accept=".gpx,.fit" multiple>
            </div>
        </div>

            <div id="dropZone">
                <p>📂 Drag and drop GPX or FIT files</p>
                <p style="font-size: 12px; color: #999;">or click to browse</p>
                <input type="file" id="fileInput" accept=".gpx,.fit" multiple>
            </div>

            <div id="fileList" class="hidden"></div>
        </div>

        <!-- Map Container -->
        <div id="mapContainer">
            <div id="map"></div>
        </div>
    </div>

    <!-- Comparison Panel (slides up from bottom) -->
    <div id="comparisonPanel">
        <div class="comparison-header">
            <h3>📊 Route Comparison</h3>
            <div class="comparison-actions">
                <button class="comparison-elevation-btn" onclick="compareMetric('elevation')" id="compareElevationBtn">📈 Elevation</button>
                <button class="comparison-elevation-btn" onclick="compareMetric('speed')" id="compareSpeedBtn">🏃 Speed</button>
                <button class="comparison-elevation-btn" onclick="compareMetric('pace')" id="comparePaceBtn">⏱️ Pace</button>
                <button class="comparison-elevation-btn" onclick="compareMetric('heartrate')" id="compareHeartRateBtn">❤️ Heart Rate</button>
                <button class="comparison-elevation-btn" onclick="compareMetric('cadence')" id="compareCadenceBtn">👟 Cadence</button>
                <button class="comparison-elevation-btn" onclick="compareMetric('power')" id="comparePowerBtn">⚡ Power</button>
                <button class="comparison-close" onclick="closeComparison()">Close</button>
            </div>
        </div>
        <div class="comparison-content">
            <table id="comparisonTableContent"></table>
        </div>
    </div>

    <div id="routeTooltip"></div>

    <div id="playbackControls">
    <span class="speed-label">Playback Speed:</span>
    <div style="display: flex; align-items: center; gap: 8px;">
        <span style="font-size: 11px; color: #999;">1x</span>
        <input type="range" id="speedSlider" min="0" max="100" value="0" style="width: 200px;">
        <span style="font-size: 11px; color: #999;">1000x</span>
        <span id="speedDisplay" style="font-size: 13px; font-weight: 600; color: #1a73e8; min-width: 50px;">1x</span>
    </div>
</div>

    <!-- Elevation Modal -->
    <div id="elevationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Elevation Profile</h2>
                <button class="modal-close" onclick="closeElevationModal()">Close</button>
            </div>
            <canvas id="elevationChart"></canvas>
            <div class="chart-controls">
                <button class="chart-control-btn" onclick="toggleDragMode()" id="dragModeBtn">✋ Drag to Align</button>
                <button class="chart-control-btn" onclick="resetChartZoom()" id="resetZoomBtn" disabled>🔍 Reset Zoom</button>
                <button class="chart-control-btn" onclick="resetOffsets()" id="resetOffsetsBtn" disabled>↺ Reset Offsets</button>
                <span id="zoomInstructions" style="color: #666; font-size: 12px;">Click and drag to zoom into a region</span>
            </div>
            <div id="chartLegend" class="chart-legend"></div>
        </div>
    </div>

    <!-- FIT File Parser Library -->
    <script type="module">
        import FitParserModule from 'https://esm.run/fit-file-parser@1.21.0';
        window.FitParser = FitParserModule.default || FitParserModule;
        window.fitParserReady = true;
        window.dispatchEvent(new Event('fitParserLoaded'));
    </script>

    <script>
        let map;
        let routes = [];
        let highlightedRoute = null;
        let compareMode = false;
        let chartZoomState = null;
        let chartMouseDown = false;
        let chartSelectionStart = null;
        let currentChartData = null;

        window.playbackSpeed = 1; // Default 1x speed
        window.playingRoutes = {}; // Track animation state for each route
        
        // Drag mode variables
        let dragMode = false;
        let selectedRouteForDrag = null;
        let routeOffsets = {}; // Store distance offsets for each route
        let isDragging = false;
        let dragStartX = null;
        let dragStartOffset = 0;
        let animationFrameId = null;
        
        const colors = [
            '#EA4335', '#4285F4', '#FBBC04', '#34A853', '#FF6D00', '#46BDC6', 
            '#7B1FA2', '#C2185B', '#00BCD4', '#8BC34A', '#FF5722', '#9C27B0',
            '#03A9F4', '#FFEB3B', '#E91E63', '#00ACC1', '#7CB342', '#F57C00',
            '#5E35B1', '#D81B60'
        ];
        
        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 40, lng: -100 },
                zoom: 4,
                mapTypeControl: true,
                streetViewControl: false
            });
        }

        function calculateDistance(coords) {
            let totalDistance = 0;
            for (let i = 1; i < coords.length; i++) {
                totalDistance += haversineDistance(coords[i-1], coords[i]);
            }
            return totalDistance;
        }

        function haversineDistance(coord1, coord2) {
            const R = 6371;
            const dLat = toRad(coord2.lat - coord1.lat);
            const dLon = toRad(coord2.lng - coord1.lng);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(toRad(coord1.lat)) * Math.cos(toRad(coord2.lat)) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function toRad(deg) {
            return deg * (Math.PI / 180);
        }

        function calculateElevationStats(elevations) {
            if (!elevations || elevations.length === 0) {
                return { gain: 0, loss: 0, min: 0, max: 0 };
            }

            let gain = 0;
            let loss = 0;
            let min = elevations[0];
            let max = elevations[0];

            for (let i = 1; i < elevations.length; i++) {
                const diff = elevations[i] - elevations[i-1];
                if (diff > 0) gain += diff;
                else loss += Math.abs(diff);
                
                if (elevations[i] < min) min = elevations[i];
                if (elevations[i] > max) max = elevations[i];
            }

            return { gain, loss, min, max };
        }

        function parseFIT(arrayBuffer, color, filename, index) {
            try {
                if (typeof FitParser === 'undefined' || !window.FitParser) {
                    alert('FIT parser is still loading. Please wait a moment and try again.');
                    return;
                }
                
                const fitParser = new FitParser({
                    force: true,
                    speedUnit: 'km/h',
                    lengthUnit: 'm',
                    temperatureUnit: 'celsius',
                    elapsedRecordField: true,
                    mode: 'list'
                });
                
                fitParser.parse(arrayBuffer, function (error, data) {
                    if (error) {
                        alert(`Error parsing FIT file ${filename}: ${error.message}`);
                        return;
                    }
                    
                    const records = data.records || [];
                    
                    if (records.length === 0) {
                        alert(`No data points found in ${filename}`);
                        return;
                    }
                    
                    const coordinates = [];
                    const elevations = [];
                    const timestamps = [];
                    const heartRates = [];
                    const cadences = [];
                    const powers = [];
                    const speeds = [];
                    const paces = [];
                    
                    records.forEach((record, i) => {
                        if (record.position_lat !== undefined && record.position_long !== undefined) {
                            const lat = record.position_lat;
                            const lng = record.position_long;
                            
                            if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
                                coordinates.push({ lat, lng });
                                
                                elevations.push(record.enhanced_altitude !== undefined ? record.enhanced_altitude : 
                                              record.altitude !== undefined ? record.altitude : null);
                                
                                timestamps.push(record.timestamp ? new Date(record.timestamp) : null);
                                heartRates.push(record.heart_rate !== undefined ? record.heart_rate : null);
                                cadences.push(record.cadence !== undefined ? record.cadence : null);
                                powers.push(record.power !== undefined ? record.power : null);
                                
                                let speedKmh = null;
                                if (record.enhanced_speed !== undefined) {
                                    speedKmh = record.enhanced_speed * 3.6;
                                } else if (record.speed !== undefined) {
                                    speedKmh = record.speed * 3.6;
                                }
                                speeds.push(speedKmh);
                                
                                if (speedKmh && speedKmh > 0) {
                                    paces.push(60 / speedKmh);
                                } else {
                                    paces.push(null);
                                }
                            }
                        }
                    });
                    
                    if (coordinates.length === 0) {
                        alert(`No valid GPS data found in ${filename}`);
                        return;
                    }
                    
                    const distance = calculateDistance(coordinates);
                    const elevStats = calculateElevationStats(elevations.filter(e => e !== null));
                    let duration = null;
                    if (timestamps.length >= 2 && timestamps[0] && timestamps[timestamps.length - 1]) {
                        duration = (timestamps[timestamps.length - 1] - timestamps[0]) / 1000 / 60;
                    }
                    
                    const polyline = new google.maps.Polyline({
                        path: coordinates,
                        geodesic: true,
                        strokeColor: color,
                        strokeOpacity: 1.0,
                        strokeWeight: 5,
                        map: map
                    });

                    const startMarker = new google.maps.Marker({
                        position: coordinates[0],
                        map: map,
                        label: {
                            text: String(index + 1),
                            color: 'white',
                            fontWeight: 'bold',
                            fontSize: '12px'
                        },
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 12,
                            fillColor: color,
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 2
                        },
                        zIndex: 1000
                    });

                    polyline.addListener('mouseover', function(e) {
                        const route = routes.find(r => r.polyline === polyline);
                        showTooltip(route ? route.displayName : filename, e.latLng);
                    });
                    
                    polyline.addListener('mousemove', function(e) {
                        const route = routes.find(r => r.polyline === polyline);
                        showTooltip(route ? route.displayName : filename, e.latLng);
                    });

                    polyline.addListener('mouseout', function() {
                        hideTooltip();
                    });

                    polyline.addListener('click', function() {
                        highlightRoute(routes.findIndex(r => r.polyline === polyline));
                    });

                    const route = { 
                        polyline, 
                        startMarker,
                        coordinates, 
                        elevations: elevations.filter(e => e !== null),
                        heartRates: heartRates.filter(hr => hr !== null),
                        cadences: cadences.filter(c => c !== null),
                        powers: powers.filter(p => p !== null),
                        speeds: speeds.filter(s => s !== null),
                        paces: paces.filter(p => p !== null),
                        timestamps,
                        color, 
                        filename,
                        displayName: filename.replace(/\.(gpx|fit)$/i, '').replace(/_/g, ' '),
                        visible: true,
                        selected: false,
                        originalWeight: 5,
                        originalOpacity: 1.0,
                        animationMarker: null,
                        isPlaying: false,
                        stats: {
                            distance: distance,
                            elevationGain: elevStats.gain,
                            elevationLoss: elevStats.loss,
                            minElevation: elevStats.min,
                            maxElevation: elevStats.max,
                            duration: duration
                        }
                    };
                    
                    routes.push(route);
                    updateFileList();
                    fitMapToRoutes();
                });
                
            } catch (error) {
                alert(`Error parsing FIT file ${filename}: ${error.message}`);
            }
        }

        function parseGPX(xmlString, color, filename, index) {
            try {
                const parser = new DOMParser();
                const xml = parser.parseFromString(xmlString, 'text/xml');
                
                const parserError = xml.getElementsByTagName('parsererror');
                if (parserError.length > 0) {
                    alert(`Invalid XML in ${filename}`);
                    return null;
                }
                
                const coordinates = [];
                const elevations = [];
                const timestamps = [];
                const heartRates = [];
                const cadences = [];
                const powers = [];
                
                const trkpts = xml.getElementsByTagName('trkpt');
                
                if (trkpts.length > 0) {
                    for (let i = 0; i < trkpts.length; i++) {
                        const lat = parseFloat(trkpts[i].getAttribute('lat'));
                        const lon = parseFloat(trkpts[i].getAttribute('lon'));
                        coordinates.push({ lat, lng: lon });
                        
                        const eleNode = trkpts[i].getElementsByTagName('ele')[0];
                        if (eleNode) {
                            elevations.push(parseFloat(eleNode.textContent));
                        } else {
                            elevations.push(null);
                        }
                        
                        const timeNode = trkpts[i].getElementsByTagName('time')[0];
                        if (timeNode) {
                            timestamps.push(new Date(timeNode.textContent));
                        } else {
                            timestamps.push(null);
                        }
                        
                        let hr = null;
                        const extensions = trkpts[i].getElementsByTagName('extensions')[0];
                        if (extensions) {
                            const hrNodes = [
                                extensions.getElementsByTagName('tpx1:hr')[0],
                                extensions.getElementsByTagName('gpxtpx:hr')[0],
                                extensions.getElementsByTagName('ns3:hr')[0],
                                extensions.getElementsByTagName('hr')[0],
                                extensions.getElementsByTagName('heartrate')[0],
                                extensions.getElementsByTagName('HeartRate')[0]
                            ];
                            for (let node of hrNodes) {
                                if (node && node.textContent) {
                                    hr = parseFloat(node.textContent);
                                    if (!isNaN(hr)) break;
                                }
                            }
                        }
                        heartRates.push(hr);
                        
                        let cad = null;
                        if (extensions) {
                            const cadNodes = [
                                extensions.getElementsByTagName('tpx1:cad')[0],
                                extensions.getElementsByTagName('gpxtpx:cad')[0],
                                extensions.getElementsByTagName('ns3:cad')[0],
                                extensions.getElementsByTagName('cad')[0],
                                extensions.getElementsByTagName('cadence')[0],
                                extensions.getElementsByTagName('Cadence')[0],
                                extensions.getElementsByTagName('RunCadence')[0]
                            ];
                            for (let node of cadNodes) {
                                if (node && node.textContent) {
                                    cad = parseFloat(node.textContent);
                                    if (!isNaN(cad)) break;
                                }
                            }
                        }
                        cadences.push(cad);
                        
                        let pwr = null;
                        if (extensions) {
                            const pwrNodes = [
                                extensions.getElementsByTagName('tpx1:power')[0],
                                extensions.getElementsByTagName('power')[0],
                                extensions.getElementsByTagName('Power')[0],
                                extensions.getElementsByTagName('gpxtpx:power')[0],
                                extensions.getElementsByTagName('ns3:power')[0],
                                extensions.getElementsByTagName('pwr')[0]
                            ];
                            for (let node of pwrNodes) {
                                if (node && node.textContent) {
                                    pwr = parseFloat(node.textContent);
                                    if (!isNaN(pwr)) break;
                                }
                            }
                        }
                        powers.push(pwr);
                    }
                } else {
                    const rtepts = xml.getElementsByTagName('rtept');
                    for (let i = 0; i < rtepts.length; i++) {
                        const lat = parseFloat(rtepts[i].getAttribute('lat'));
                        const lon = parseFloat(rtepts[i].getAttribute('lon'));
                        coordinates.push({ lat, lng: lon });
                        
                        const eleNode = rtepts[i].getElementsByTagName('ele')[0];
                        if (eleNode) {
                            elevations.push(parseFloat(eleNode.textContent));
                        } else {
                            elevations.push(null);
                        }
                    }
                }

                if (coordinates.length === 0) {
                    alert(`No track points found in ${filename}`);
                    return null;
                }

                const speeds = [];
                const paces = [];
                
                for (let i = 0; i < coordinates.length; i++) {
                    if (i === 0 || !timestamps[i] || !timestamps[i-1]) {
                        speeds.push(null);
                        paces.push(null);
                    } else {
                        const dist = haversineDistance(coordinates[i-1], coordinates[i]);
                        const timeDiff = (timestamps[i] - timestamps[i-1]) / 1000 / 3600;
                        
                        if (timeDiff > 0 && dist > 0) {
                            const speed = dist / timeDiff;
                            speeds.push(speed);
                            
                            const pace = 60 / speed;
                            paces.push(pace);
                        } else {
                            speeds.push(null);
                            paces.push(null);
                        }
                    }
                }

                const distance = calculateDistance(coordinates);
                const elevStats = calculateElevationStats(elevations.filter(e => e !== null));
                let duration = null;
                if (timestamps.length >= 2 && timestamps[0] && timestamps[timestamps.length - 1]) {
                    duration = (timestamps[timestamps.length - 1] - timestamps[0]) / 1000 / 60;
                }

                const polyline = new google.maps.Polyline({
                    path: coordinates,
                    geodesic: true,
                    strokeColor: color,
                    strokeOpacity: 1.0,
                    strokeWeight: 5,
                    map: map
                });

                const startMarker = new google.maps.Marker({
                    position: coordinates[0],
                    map: map,
                    label: {
                        text: String(index + 1),
                        color: 'white',
                        fontWeight: 'bold',
                        fontSize: '12px'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 12,
                        fillColor: color,
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 2
                    },
                    zIndex: 1000
                });

                polyline.addListener('mouseover', function(e) {
                    const route = routes.find(r => r.polyline === polyline);
                    showTooltip(route ? route.displayName : filename, e.latLng);
                });
                
                polyline.addListener('mousemove', function(e) {
                    const route = routes.find(r => r.polyline === polyline);
                    showTooltip(route ? route.displayName : filename, e.latLng);
                });

                polyline.addListener('mouseout', function() {
                    hideTooltip();
                });

                polyline.addListener('click', function() {
                    highlightRoute(routes.findIndex(r => r.polyline === polyline));
                });

                return { 
                    polyline, 
                    startMarker,
                    coordinates, 
                    elevations: elevations.filter(e => e !== null),
                    heartRates: heartRates.filter(hr => hr !== null),
                    cadences: cadences.filter(c => c !== null),
                    powers: powers.filter(p => p !== null),
                    speeds: speeds.filter(s => s !== null),
                    paces: paces.filter(p => p !== null),
                    timestamps,
                    color, 
                    filename,
                    displayName: filename.replace(/\.(gpx|fit)$/i, '').replace(/_/g, ' '),
                    visible: true,
                    selected: false,
                    originalWeight: 5,
                    originalOpacity: 1.0,
                    animationMarker: null,
                    isPlaying: false,
                    stats: {
                        distance: distance,
                        elevationGain: elevStats.gain,
                        elevationLoss: elevStats.loss,
                        minElevation: elevStats.min,
                        maxElevation: elevStats.max,
                        duration: duration
                    }
                };
            } catch (error) {
                alert(`Error parsing ${filename}: ${error.message}`);
                return null;
            }
        }

        function formatDistance(km) {
            return km >= 1 ? `${km.toFixed(2)} km` : `${(km * 1000).toFixed(0)} m`;
        }

        function formatElevation(m) {
            return `${Math.round(m)} m`;
        }

        function formatDuration(minutes) {
            if (!minutes) return 'N/A';
            const hours = Math.floor(minutes / 60);
            const mins = Math.round(minutes % 60);
            return hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
        }

        function showTooltip(text, latLng) {
            const tooltip = document.getElementById('routeTooltip');
            tooltip.textContent = text;
            tooltip.style.display = 'block';
            
            const projection = map.getProjection();
            const point = projection.fromLatLngToPoint(latLng);
            const scale = Math.pow(2, map.getZoom());
            
            const pixelOffset = new google.maps.Point(
                Math.floor(point.x * scale),
                Math.floor(point.y * scale)
            );
            
            const bounds = map.getBounds();
            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            const topRight = projection.fromLatLngToPoint(ne);
            const bottomLeft = projection.fromLatLngToPoint(sw);
            
            const x = (pixelOffset.x - bottomLeft.x * scale);
            const y = (pixelOffset.y - topRight.y * scale);
            
            const mapDiv = document.getElementById('map');
            const rect = mapDiv.getBoundingClientRect();
            
            tooltip.style.left = (rect.left + x + 10) + 'px';
            tooltip.style.top = (rect.top + y - 30) + 'px';
        }

        function hideTooltip() {
            document.getElementById('routeTooltip').style.display = 'none';
        }

        function highlightRoute(index) {
            if (highlightedRoute !== null) {
                const prevRoute = routes[highlightedRoute];
                if (prevRoute && prevRoute.visible) {
                    prevRoute.polyline.setOptions({
                        strokeWeight: prevRoute.originalWeight,
                        strokeOpacity: prevRoute.originalOpacity
                    });
                }
                document.querySelectorAll('.file-item').forEach(el => {
                    el.classList.remove('highlighted');
                });
            }

            if (index !== null && routes[index]) {
                const route = routes[index];
                route.polyline.setOptions({
                    strokeWeight: 8,
                    strokeOpacity: 1.0
                });
                
                const fileItems = document.querySelectorAll('.file-item');
                if (fileItems[index]) {
                    fileItems[index].classList.add('highlighted');
                    fileItems[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }

                highlightedRoute = index;

                setTimeout(() => {
                    if (highlightedRoute === index) {
                        route.polyline.setOptions({
                            strokeWeight: route.originalWeight,
                            strokeOpacity: route.originalOpacity
                        });
                        fileItems[index].classList.remove('highlighted');
                        highlightedRoute = null;
                    }
                }, 2000);
            }
        }

        function toggleRouteVisibility(index) {
            const route = routes[index];
            route.visible = !route.visible;
            
            route.polyline.setMap(route.visible ? map : null);
            route.startMarker.setMap(route.visible ? map : null);
            
            updateFileList();
        }

        function showElevationProfile(index) {
            const route = routes[index];
            if (!route.elevations || route.elevations.length === 0) {
                alert('No elevation data available for this route');
                return;
            }

            document.getElementById('modalTitle').textContent = `Elevation Profile: ${route.displayName}`;
            document.getElementById('elevationModal').classList.add('show');
            
            drawElevationChart([route]);
        }

        function compareElevationProfiles() {
            const selectedRoutes = routes.filter(r => r.selected && r.elevations && r.elevations.length > 0);
            
            if (selectedRoutes.length < 2) {
                alert('Please select at least 2 routes with elevation data');
                return;
            }

            document.getElementById('modalTitle').textContent = `Elevation Profile Comparison (${selectedRoutes.length} routes)`;
            document.getElementById('elevationModal').classList.add('show');
            
            drawElevationChart(selectedRoutes);
        }

        function compareMetric(metricType) {
            const selectedRoutes = routes.filter(r => r.selected);
            
            let validRoutes = [];
            let metricName = '';
            let yAxisLabel = '';
            let formatValue = null;
            
            switch(metricType) {
                case 'elevation':
                    validRoutes = selectedRoutes.filter(r => r.elevations && r.elevations.length > 0);
                    metricName = 'Elevation';
                    yAxisLabel = 'Elevation (m)';
                    formatValue = (v) => Math.round(v) + 'm';
                    break;
                case 'speed':
                    validRoutes = selectedRoutes.filter(r => r.speeds && r.speeds.length > 0);
                    metricName = 'Speed';
                    yAxisLabel = 'Speed (km/h)';
                    formatValue = (v) => v.toFixed(1) + ' km/h';
                    break;
                case 'pace':
                    validRoutes = selectedRoutes.filter(r => r.paces && r.paces.length > 0);
                    metricName = 'Pace';
                    yAxisLabel = 'Pace (min/km)';
                    formatValue = (v) => {
                        const mins = Math.floor(v);
                        const secs = Math.round((v - mins) * 60);
                        return `${mins}:${secs.toString().padStart(2, '0')} min/km`;
                    };
                    break;
                case 'heartrate':
                    validRoutes = selectedRoutes.filter(r => r.heartRates && r.heartRates.length > 0);
                    metricName = 'Heart Rate';
                    yAxisLabel = 'Heart Rate (bpm)';
                    formatValue = (v) => Math.round(v) + ' bpm';
                    break;
                case 'cadence':
                    validRoutes = selectedRoutes.filter(r => r.cadences && r.cadences.length > 0);
                    metricName = 'Cadence';
                    yAxisLabel = 'Cadence (spm)';
                    formatValue = (v) => Math.round(v) + ' spm';
                    break;
                case 'power':
                    validRoutes = selectedRoutes.filter(r => r.powers && r.powers.length > 0);
                    metricName = 'Power';
                    yAxisLabel = 'Power (W)';
                    formatValue = (v) => Math.round(v) + 'W';
                    break;
            }
            
            if (validRoutes.length < 2) {
                alert(`Please select at least 2 routes with ${metricName.toLowerCase()} data`);
                return;
            }

            document.getElementById('modalTitle').textContent = `${metricName} Comparison (${validRoutes.length} routes)`;
            document.getElementById('elevationModal').classList.add('show');
            
            drawMetricChart(validRoutes, metricType, yAxisLabel, formatValue);
        }

        function toggleDragMode() {
            dragMode = !dragMode;
            const btn = document.getElementById('dragModeBtn');
            const canvas = document.getElementById('elevationChart');
            const instructions = document.getElementById('zoomInstructions');
            
            if (dragMode) {
                btn.classList.add('active');
                btn.textContent = '✋ Drag Mode Active';
                canvas.classList.add('drag-mode');
                instructions.textContent = 'Click a route in the legend, then drag it horizontally to align';
                updateLegend(); // Update legend to add click handlers
            } else {
                btn.classList.remove('active');
                btn.textContent = '✋ Drag to Align';
                canvas.classList.remove('drag-mode');
                selectedRouteForDrag = null;
                instructions.textContent = 'Click and drag to zoom into a region';
                updateLegend();
            }
        }

        function resetOffsets() {
            routeOffsets = {};
            document.getElementById('resetOffsetsBtn').disabled = true;
            
            if (currentChartData) {
                drawMetricChart(
                    currentChartData.routes,
                    currentChartData.metricType,
                    currentChartData.yAxisLabel,
                    currentChartData.formatValue
                );
            }
        }

        function resetChartZoom() {
            chartZoomState = null;
            document.getElementById('resetZoomBtn').disabled = true;
            
            if (currentChartData) {
                drawMetricChart(
                    currentChartData.routes,
                    currentChartData.metricType,
                    currentChartData.yAxisLabel,
                    currentChartData.formatValue
                );
            }
        }

        function setupChartInteraction(canvas, routesWithData, maxDistance) {
            // Only setup once - check if already initialized
            if (canvas.dataset.interactionInitialized === 'true') {
                return;
            }
            canvas.dataset.interactionInitialized = 'true';
            
            // Store max distance globally
            currentMaxDistance = maxDistance;
            
            const ctx = canvas.getContext('2d');
            const padding = 50;
            
            let selectionRect = null;
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const chartWidth = canvas.width - padding * 2;
                
                if (x >= padding && x <= padding + chartWidth) {
                    if (dragMode && selectedRouteForDrag !== null) {
                        // Start dragging - use current chart data, not stale routesWithData
                        isDragging = true;
                        dragStartX = x;
                        const routeId = currentChartData.routes[selectedRouteForDrag].filename;
                        dragStartOffset = routeOffsets[routeId] || 0;
                        canvas.classList.add('dragging');
                    } else if (!dragMode) {
                        // Start zoom selection
                        chartMouseDown = true;
                        chartSelectionStart = { x, y };
                        selectionRect = null;
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const chartWidth = canvas.width - padding * 2;
                
                if (isDragging && selectedRouteForDrag !== null) {
                    // Calculate new offset using current data
                    const pixelDiff = x - dragStartX;
                    const distanceDiff = (pixelDiff / chartWidth) * currentMaxDistance;
                    const routeId = currentChartData.routes[selectedRouteForDrag].filename;
                    routeOffsets[routeId] = dragStartOffset + distanceDiff;
                    
                    document.getElementById('resetOffsetsBtn').disabled = false;
                    
                    // Use requestAnimationFrame to throttle redraws
                    if (!animationFrameId) {
                        animationFrameId = requestAnimationFrame(() => {
                            if (currentChartData) {
                                drawMetricChart(
                                    currentChartData.routes,
                                    currentChartData.metricType,
                                    currentChartData.yAxisLabel,
                                    currentChartData.formatValue
                                );
                            }
                            animationFrameId = null;
                        });
                    }
                } else if (chartMouseDown && chartSelectionStart) {
                    const y = e.clientY - rect.top;
                    
                    selectionRect = {
                        startX: Math.min(chartSelectionStart.x, x),
                        startY: Math.min(chartSelectionStart.y, y),
                        width: Math.abs(x - chartSelectionStart.x),
                        height: Math.abs(y - chartSelectionStart.y)
                    };
                    
                    if (currentChartData) {
                        drawMetricChart(
                            currentChartData.routes,
                            currentChartData.metricType,
                            currentChartData.yAxisLabel,
                            currentChartData.formatValue
                        );
                        
                        ctx.strokeStyle = '#1a73e8';
                        ctx.fillStyle = 'rgba(26, 115, 232, 0.1)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(selectionRect.startX, selectionRect.startY, selectionRect.width, selectionRect.height);
                        ctx.fillRect(selectionRect.startX, selectionRect.startY, selectionRect.width, selectionRect.height);
                    }
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    canvas.classList.remove('dragging');
                    // Cancel any pending animation frame
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    // Do one final redraw
                    if (currentChartData) {
                        drawMetricChart(
                            currentChartData.routes,
                            currentChartData.metricType,
                            currentChartData.yAxisLabel,
                            currentChartData.formatValue
                        );
                    }
                } else if (chartMouseDown && chartSelectionStart) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const chartWidth = canvas.width - padding * 2;
                    
                    const startX = Math.min(chartSelectionStart.x, x);
                    const endX = Math.max(chartSelectionStart.x, x);
                    
                    if (Math.abs(endX - startX) > 20) {
                        const minDistance = ((startX - padding) / chartWidth) * currentMaxDistance;
                        const maxDistanceZoom = ((endX - padding) / chartWidth) * currentMaxDistance;
                        
                        chartZoomState = {
                            minDistance: Math.max(0, minDistance),
                            maxDistance: Math.min(currentMaxDistance, maxDistanceZoom)
                        };
                        
                        document.getElementById('resetZoomBtn').disabled = false;
                        
                        if (currentChartData) {
                            drawMetricChart(
                                currentChartData.routes,
                                currentChartData.metricType,
                                currentChartData.yAxisLabel,
                                currentChartData.formatValue
                            );
                        }
                    }
                }
                
                chartMouseDown = false;
                chartSelectionStart = null;
            });
            
            canvas.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    canvas.classList.remove('dragging');
                    // Cancel any pending animation frame
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                }
                chartMouseDown = false;
                chartSelectionStart = null;
            });
        }

        function updateLegend() {
            if (!currentChartData) return;
            
            const legendDiv = document.getElementById('chartLegend');
            legendDiv.innerHTML = '';
            
            currentChartData.routes.forEach((route, index) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                if (selectedRouteForDrag === index) {
                    item.classList.add('active');
                }
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.background = route.color;
                
                const label = document.createElement('span');
                label.className = 'legend-label';
                label.textContent = `${route.displayName} (${formatDistance(route.stats.distance)})`;
                
                const offset = routeOffsets[route.filename] || 0;
                if (Math.abs(offset) > 0.01) {
                    const offsetSpan = document.createElement('span');
                    offsetSpan.className = 'legend-offset';
                    offsetSpan.textContent = offset >= 0 ? `+${formatDistance(offset)}` : formatDistance(offset);
                    label.appendChild(offsetSpan);
                }
                
                item.appendChild(colorBox);
                item.appendChild(label);
                
                if (dragMode) {
                    item.style.cursor = 'pointer';
                    item.onclick = () => {
                        selectedRouteForDrag = selectedRouteForDrag === index ? null : index;
                        updateLegend();
                    };
                }
                
                legendDiv.appendChild(item);
            });
        }

        function getAdaptiveSmoothingParams(totalDistanceKm) {
            if (totalDistanceKm < 10) {
                return { windowSize: 50, decimationFactor: 5 };
            } else if (totalDistanceKm < 25) {
                return { windowSize: 100, decimationFactor: 10 };
            } else if (totalDistanceKm < 50) {
                return { windowSize: 200, decimationFactor: 15 };
            } else if (totalDistanceKm < 100) {
                return { windowSize: 300, decimationFactor: 25 };
            } else {
                return { windowSize: 500, decimationFactor: 50 };
            }
        }

        function smoothData(data, windowSize = 20) {
            if (data.length < windowSize) return data;
            
            const smoothed = [];
            for (let i = 0; i < data.length; i++) {
                const start = Math.max(0, i - Math.floor(windowSize / 2));
                const end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                
                let sum = 0;
                let count = 0;
                for (let j = start; j < end; j++) {
                    if (data[j] !== null && data[j] !== undefined) {
                        sum += data[j];
                        count++;
                    }
                }
                
                smoothed.push(count > 0 ? sum / count : data[i]);
            }
            
            return smoothed;
        }

        function decimateData(data, distances, factor = 20) {
            if (data.length <= factor * 2) return { data, distances };
            
            const decimatedData = [data[0]];
            const decimatedDistances = [distances[0]];
            
            for (let i = factor; i < data.length - 1; i += factor) {
                decimatedData.push(data[i]);
                decimatedDistances.push(distances[i]);
            }
            
            decimatedData.push(data[data.length - 1]);
            decimatedDistances.push(distances[distances.length - 1]);
            
            return { data: decimatedData, distances: decimatedDistances };
        }

        function drawMetricChart(routesToDraw, metricType, yAxisLabel, formatValue) {
            currentChartData = { routes: routesToDraw, metricType, yAxisLabel, formatValue };
            
            const canvas = document.getElementById('elevationChart');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const padding = 50;
            const chartWidth = canvas.width - padding * 2;
            const chartHeight = canvas.height - padding * 2;
            
            const routesWithData = routesToDraw.map(route => {
                const distances = [0];
                for (let i = 1; i < route.coordinates.length; i++) {
                    const segmentDist = haversineDistance(route.coordinates[i-1], route.coordinates[i]);
                    distances.push(distances[i-1] + segmentDist);
                }
                
                const totalDistanceKm = distances[distances.length - 1];
                
                let metricData = [];
                switch(metricType) {
                    case 'elevation':
                        metricData = route.elevations;
                        break;
                    case 'speed':
                        metricData = route.speeds;
                        break;
                    case 'pace':
                        metricData = route.paces;
                        break;
                    case 'heartrate':
                        metricData = route.heartRates;
                        break;
                    case 'cadence':
                        metricData = route.cadences;
                        break;
                    case 'power':
                        metricData = route.powers;
                        break;
                }
                
                const { windowSize, decimationFactor } = getAdaptiveSmoothingParams(totalDistanceKm);
                const smoothedData = smoothData(metricData, windowSize);
                const { data: finalData, distances: finalDistances } = decimateData(smoothedData, distances, decimationFactor);
                
                // Apply offset
                const offset = routeOffsets[route.filename] || 0;
                const offsetDistances = finalDistances.map(d => d + offset);
                
                return {
                    ...route,
                    cumulativeDistances: offsetDistances,
                    totalDistance: distances[distances.length - 1],
                    metricData: finalData
                };
            });
            
            let globalMin = Infinity;
            let globalMax = -Infinity;
            let maxDistance = 0;
            
            const originalMaxDistance = Math.max(...routesWithData.map(r => {
                const offset = routeOffsets[r.filename] || 0;
                return r.totalDistance + offset;
            }));
            
            const zoomedRoutes = routesWithData.map(route => {
                if (chartZoomState) {
                    const filteredData = [];
                    const filteredDistances = [];
                    
                    for (let i = 0; i < route.cumulativeDistances.length; i++) {
                        const dist = route.cumulativeDistances[i];
                        if (dist >= chartZoomState.minDistance && dist <= chartZoomState.maxDistance) {
                            filteredData.push(route.metricData[i]);
                            filteredDistances.push(dist - chartZoomState.minDistance);
                        }
                    }
                    
                    return {
                        ...route,
                        metricData: filteredData,
                        cumulativeDistances: filteredDistances,
                        totalDistance: chartZoomState.maxDistance - chartZoomState.minDistance
                    };
                }
                return route;
            });
            
            zoomedRoutes.forEach(route => {
                if (route.metricData.length > 0) {
                    const min = Math.min(...route.metricData);
                    const max = Math.max(...route.metricData);
                    if (min < globalMin) globalMin = min;
                    if (max > globalMax) globalMax = max;
                }
                const routeMax = Math.max(...route.cumulativeDistances);
                if (routeMax > maxDistance) maxDistance = routeMax;
            });
            
            const range = globalMax - globalMin;
            const padding_percent = 0.1;
            globalMin = globalMin - (range * padding_percent);
            globalMax = globalMax + (range * padding_percent);
            const adjustedRange = globalMax - globalMin;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
                
                const value = globalMax - (adjustedRange / 5) * i;
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(formatValue(value), padding - 5, y + 4);
            }
            
            for (let i = 0; i <= 5; i++) {
                const x = padding + (chartWidth / 5) * i;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + chartHeight);
                ctx.stroke();
                
                const dist = (maxDistance / 5) * i;
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(formatDistance(dist), x, canvas.height - padding + 25);
            }
            
            // Draw each route
            zoomedRoutes.forEach((route, routeIndex) => {
                const metricData = route.metricData;
                const distances = route.cumulativeDistances;
                
                const dataLength = Math.min(metricData.length, distances.length);
                
                if (routesToDraw.length === 1) {
                    ctx.strokeStyle = route.color;
                    ctx.fillStyle = route.color + '25';
                    ctx.lineWidth = 1.5;
                    
                    ctx.beginPath();
                    ctx.moveTo(padding, canvas.height - padding);
                    
                    for (let i = 0; i < dataLength; i++) {
                        if (metricData[i] !== null && metricData[i] !== undefined) {
                            const x = padding + (distances[i] / maxDistance) * chartWidth;
                            const y = padding + chartHeight - ((metricData[i] - globalMin) / adjustedRange) * chartHeight;
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    const lastX = padding + (distances[dataLength - 1] / maxDistance) * chartWidth;
                    ctx.lineTo(lastX, canvas.height - padding);
                    ctx.lineTo(padding, canvas.height - padding);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.strokeStyle = route.color;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                
                let firstPoint = true;
                for (let i = 0; i < dataLength; i++) {
                    if (metricData[i] !== null && metricData[i] !== undefined) {
                        const x = padding + (distances[i] / maxDistance) * chartWidth;
                        const y = padding + chartHeight - ((metricData[i] - globalMin) / adjustedRange) * chartHeight;
                        
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            });
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + chartHeight);
            ctx.lineTo(padding + chartWidth, padding + chartHeight);
            ctx.stroke();
            
            // Y-axis label
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(yAxisLabel, 0, 0);
            ctx.restore();
            
            // X-axis label
            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Distance', canvas.width / 2, canvas.height - 10);
            
            updateLegend();
            
            // Update current max distance for event handlers
            currentMaxDistance = originalMaxDistance;
            
            setupChartInteraction(canvas, zoomedRoutes, originalMaxDistance);
        }

        function drawElevationChart(routesToDraw) {
            drawMetricChart(routesToDraw, 'elevation', 'Elevation (m)', (v) => Math.round(v) + 'm');
        }

        function closeElevationModal() {
            document.getElementById('elevationModal').classList.remove('show');
            chartZoomState = null;
            currentChartData = null;
            dragMode = false;
            selectedRouteForDrag = null;
            routeOffsets = {};
            document.getElementById('resetZoomBtn').disabled = true;
            document.getElementById('resetOffsetsBtn').disabled = true;
            document.getElementById('dragModeBtn').classList.remove('active');
            document.getElementById('dragModeBtn').textContent = '✋ Drag to Align';
            
            // Reset interaction flag so it can be reinitialized next time
            const canvas = document.getElementById('elevationChart');
            canvas.dataset.interactionInitialized = 'false';
            
            // Cancel any pending animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function toggleCompareMode() {
            compareMode = !compareMode;
            const btn = document.getElementById('compareBtn');
            const fileList = document.getElementById('fileList');
            
            if (compareMode) {
                btn.classList.add('active');
                btn.textContent = '✓ Compare Mode';
                fileList.classList.add('compare-mode');
            } else {
                btn.classList.remove('active');
                btn.textContent = '📊 Compare Routes';
                fileList.classList.remove('compare-mode');
                routes.forEach(r => r.selected = false);
                closeComparison();
            }
            
            updateFileList();
        }

        function toggleRouteSelection(index) {
            if (!compareMode) return;
            
            routes[index].selected = !routes[index].selected;
            updateFileList();
            updateComparison();
        }

        function updateComparison() {
            const selectedRoutes = routes.filter(r => r.selected);
            const comparisonPanel = document.getElementById('comparisonPanel');
            const table = document.getElementById('comparisonTableContent');
            
            if (selectedRoutes.length < 2) {
                comparisonPanel.classList.remove('show');
                return;
            }
            
            const hasElevation = selectedRoutes.some(r => r.elevations && r.elevations.length > 0);
            const hasSpeed = selectedRoutes.some(r => r.speeds && r.speeds.length > 0);
            const hasPace = selectedRoutes.some(r => r.paces && r.paces.length > 0);
            const hasHeartRate = selectedRoutes.some(r => r.heartRates && r.heartRates.length > 0);
            const hasCadence = selectedRoutes.some(r => r.cadences && r.cadences.length > 0);
            const hasPower = selectedRoutes.some(r => r.powers && r.powers.length > 0);
            
            const elevBtn = document.getElementById('compareElevationBtn');
            const speedBtn = document.getElementById('compareSpeedBtn');
            const paceBtn = document.getElementById('comparePaceBtn');
            const hrBtn = document.getElementById('compareHeartRateBtn');
            const cadBtn = document.getElementById('compareCadenceBtn');
            const pwrBtn = document.getElementById('comparePowerBtn');
            
            if (elevBtn) elevBtn.disabled = !hasElevation;
            if (speedBtn) speedBtn.disabled = !hasSpeed;
            if (paceBtn) paceBtn.disabled = !hasPace;
            if (hrBtn) hrBtn.disabled = !hasHeartRate;
            if (cadBtn) cadBtn.disabled = !hasCadence;
            if (pwrBtn) pwrBtn.disabled = !hasPower;
            
            comparisonPanel.classList.add('show');
            
            let html = `
                <thead>
                    <tr>
                        <th>Route</th>
                        <th>Distance</th>
                        <th>Elevation Gain</th>
                        <th>Min Elevation</th>
                        <th>Max Elevation</th>
                        <th>Duration</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            selectedRoutes.forEach(route => {
                html += `
                    <tr>
                        <td>
                            <div class="route-name-cell">
                                <div class="route-color-indicator" style="background: ${route.color}"></div>
                                <strong>${route.displayName}</strong>
                            </div>
                        </td>
                        <td>${formatDistance(route.stats.distance)}</td>
                        <td>${formatElevation(route.stats.elevationGain)}</td>
                        <td>${formatElevation(route.stats.minElevation)}</td>
                        <td>${formatElevation(route.stats.maxElevation)}</td>
                        <td>${formatDuration(route.stats.duration)}</td>
                    </tr>
                `;
            });
            
            html += '</tbody>';
            table.innerHTML = html;
        }

        function closeComparison() {
            document.getElementById('comparisonPanel').classList.remove('show');
        }

        function handleFiles(files) {
            Array.from(files).forEach((file, index) => {
                const isGPX = file.name.toLowerCase().endsWith('.gpx');
                const isFIT = file.name.toLowerCase().endsWith('.fit');
                
                if (!isGPX && !isFIT) {
                    alert(`${file.name} is not a GPX or FIT file`);
                    return;
                }

                const reader = new FileReader();
                reader.onerror = function() {
                    alert(`Error reading ${file.name}`);
                };
                
                if (isGPX) {
                    reader.onload = function(e) {
                        const color = colors[routes.length % colors.length];
                        const route = parseGPX(e.target.result, color, file.name, routes.length);
                        
                        if (route) {
                            routes.push(route);
                            updateFileList();
                            fitMapToRoutes();
                        }
                    };
                    reader.readAsText(file);
                } else if (isFIT) {
                    reader.onload = function(e) {
                        const color = colors[routes.length % colors.length];
                        parseFIT(e.target.result, color, file.name, routes.length);
                    };
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            const dropZone = document.getElementById('dropZone');
            const compactDropZone = document.getElementById('compactDropZone');
            
            if (routes.length === 0) {
                fileList.classList.add('hidden');
                dropZone.classList.remove('hidden');
                compactDropZone.classList.add('hidden');
            } else {
                fileList.classList.remove('hidden');
                dropZone.classList.add('hidden');
                compactDropZone.classList.remove('hidden');
            }
            
            fileList.innerHTML = '';

            routes.forEach((route, index) => {
                const item = document.createElement('div');
                item.className = 'file-item';
                if (route.selected) item.classList.add('selected');
                
                item.onclick = function(e) {
                    if (e.target.classList.contains('file-display-name') || 
                        e.target.classList.contains('compare-checkbox')) return;
                    if (!compareMode) {
                        highlightRoute(index);
                    }
                };
                
                if (compareMode) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'compare-checkbox';
                    checkbox.checked = route.selected;
                    checkbox.onclick = function(e) {
                        e.stopPropagation();
                        toggleRouteSelection(index);
                    };
                    item.appendChild(checkbox);
                }
                
                const header = document.createElement('div');
                header.className = 'file-header';
                
                const number = document.createElement('div');
                number.className = 'file-number';
                number.textContent = index + 1;
                number.style.borderColor = route.color;
                number.style.color = route.color;
                
                const colorBox = document.createElement('div');
                colorBox.className = 'file-color';
                colorBox.style.background = route.color;
                
                header.appendChild(number);
                header.appendChild(colorBox);
                
                const nameContainer = document.createElement('div');
                nameContainer.className = 'file-name-container';
                
                const displayNameEl = document.createElement('div');
                displayNameEl.className = 'file-display-name';
                displayNameEl.contentEditable = true;
                displayNameEl.textContent = route.displayName;
                displayNameEl.spellcheck = false;
                displayNameEl.title = 'Click to edit display name';
                
                displayNameEl.addEventListener('blur', function() {
                    route.displayName = this.textContent.trim() || route.displayName;
                    this.textContent = route.displayName;
                });
                
                displayNameEl.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.blur();
                    }
                });
                
                displayNameEl.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                
                const originalNameEl = document.createElement('div');
                originalNameEl.className = 'file-original-name';
                originalNameEl.textContent = route.filename;
                originalNameEl.title = route.filename;
                
                nameContainer.appendChild(displayNameEl);
                nameContainer.appendChild(originalNameEl);
                
                const statsDiv = document.createElement('div');
                statsDiv.className = 'file-stats';
                statsDiv.innerHTML = `
                    <div class="stat-row">
                        <span class="stat-label">Distance:</span>
                        <span class="stat-value">${formatDistance(route.stats.distance)}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Elev Gain:</span>
                        <span class="stat-value">${formatElevation(route.stats.elevationGain)}</span>
                    </div>
                    ${route.stats.duration ? `
                    <div class="stat-row">
                        <span class="stat-label">Duration:</span>
                        <span class="stat-value">${formatDuration(route.stats.duration)}</span>
                    </div>` : ''}
                `;
                
                const actions = document.createElement('div');
                actions.className = 'file-actions';
                
                if (route.elevations && route.elevations.length > 0) {
                    const elevBtn = document.createElement('button');
                    elevBtn.className = 'elevation-chart-btn';
                    elevBtn.textContent = '📈 Elevation';
                    elevBtn.onclick = function(e) {
                        e.stopPropagation();
                        showElevationProfile(index);
                    };
                    actions.appendChild(elevBtn);
                }
                
                // Add play button if route has valid timestamps
                const hasValidTimestamps = route.timestamps && route.timestamps.some(t => t !== null && t !== undefined);
                if (hasValidTimestamps) {
                    const playBtn = document.createElement('button');
                    playBtn.className = 'file-play' + (route.isPlaying ? ' playing' : '');
                    playBtn.textContent = route.isPlaying ? '⏸️ Pause' : '▶️ Play';
                    playBtn.onclick = function(e) {
                        e.stopPropagation();
                        toggleRouteAnimation(index);
                    };
                    actions.appendChild(playBtn);
                }
                
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'file-toggle' + (route.visible ? '' : ' hidden-route');
                toggleBtn.textContent = route.visible ? '👁️' : '👁️';
                toggleBtn.onclick = function(e) {
                    e.stopPropagation();
                    toggleRouteVisibility(index);
                };
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'file-remove';
                removeBtn.textContent = '×';
                removeBtn.onclick = function(e) {
                    e.stopPropagation();
                    removeRoute(index);
                };
                
                actions.appendChild(toggleBtn);
                actions.appendChild(removeBtn);
                
                item.appendChild(header);
                item.appendChild(nameContainer);
                item.appendChild(statsDiv);
                item.appendChild(actions);
                
                fileList.appendChild(item);
            });
        }

        function removeRoute(index) {
            // Stop animation if playing
            if (routes[index].isPlaying) {
                stopRouteAnimation(index);
            }
            
            routes[index].polyline.setMap(null);
            routes[index].startMarker.setMap(null);
            if (routes[index].animationMarker) {
                routes[index].animationMarker.setMap(null);
            }
            routes.splice(index, 1);
            updateFileList();
            
            if (compareMode) {
                updateComparison();
            }
            
            if (routes.length === 0) {
                closeComparison();
                map.setCenter({ lat: 40, lng: -100 });
                map.setZoom(4);
            } else {
                fitMapToRoutes();
            }
        }

        function toggleRouteAnimation(index) {
            const route = routes[index];
            
            if (route.isPlaying) {
                stopRouteAnimation(index);
            } else {
                startRouteAnimation(index);
            }
            
            updateFileList();
        }

        function startRouteAnimation(index) {
            const route = routes[index];
            
            // Can't animate without timestamps
            if (!route.timestamps || route.timestamps.length === 0) {
                alert('No timestamp data available for animation');
                return;
            }
            
            // Create animation marker if it doesn't exist
            if (!route.animationMarker) {
                route.animationMarker = new google.maps.Marker({
                    position: route.coordinates[0],
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: route.color,
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 3
                    },
                    zIndex: 2000
                });
                console.log('Created new animation marker at', route.coordinates[0]);
            } else {
                route.animationMarker.setPosition(route.coordinates[0]);
                route.animationMarker.setMap(map);
                console.log('Reusing existing animation marker');
            }
            
            route.isPlaying = true;
            
            // Initialize animation state
            if (typeof window.playingRoutes === 'undefined') {
                console.error('ERROR: playingRoutes is not defined!');
                window.playingRoutes = {};
            }
            
            window.playingRoutes[index] = {
                currentIndex: 0,
                startTime: Date.now(),
                pauseTime: 0
            };
            
            console.log('Animation state initialized:', window.playingRoutes[index]);
            
            animateRoute(index);

            document.getElementById('playbackControls').classList.add('show');
        }

        function stopRouteAnimation(index) {
            const route = routes[index];
            
            route.isPlaying = false;
            
            if (route.animationMarker) {
                route.animationMarker.setMap(null);
            }
            
            if (playingRoutes[index]) {
                delete playingRoutes[index];
            }

            const anyRoutePlaying = routes.some(r => r.isPlaying);
            if (!anyRoutePlaying) {
                document.getElementById('playbackControls').classList.remove('show');
            }
        }

        function animateRoute(index) {
            const route = routes[index];
            const state = playingRoutes[index];
            
            if (!route.isPlaying || !state) {
                console.log('Animation stopped: isPlaying=' + route.isPlaying + ', state exists=' + !!state);
                return;
            }
            
            // Calculate elapsed time
            const elapsedMs = (Date.now() - state.startTime) * window.playbackSpeed;
            
            // Find the coordinate index based on elapsed time
            const firstValidTimestamp = route.timestamps.find(t => t !== null);
            if (!firstValidTimestamp) {
                console.error('No valid timestamps found during animation');
                stopRouteAnimation(index);
                return;
            }
            
            const startTimestamp = firstValidTimestamp.getTime();
            
            let targetIndex = 0;
            let matchCount = 0;
            for (let i = 0; i < route.timestamps.length; i++) {
                if (route.timestamps[i]) {
                    const pointTime = route.timestamps[i].getTime() - startTimestamp;
                    if (pointTime <= elapsedMs) {
                        targetIndex = i;
                        matchCount++;
                    } else {
                        break;
                    }
                }
            }
            
            // Debug logging (log every 100 frames to avoid spam)
            if (state.currentIndex % 100 === 0) {
                console.log(`Animation frame: index=${targetIndex}/${route.coordinates.length}, elapsed=${(elapsedMs/1000).toFixed(1)}s, speed=${window.playbackSpeed}x, matchCount=${matchCount}`);
                // Log time range
                const lastValidTimestamp = [...route.timestamps].reverse().find(t => t !== null);
                const totalDuration = lastValidTimestamp ? (lastValidTimestamp.getTime() - startTimestamp) / 1000 : 0;
                console.log(`  Total activity duration: ${totalDuration.toFixed(1)}s`);
            }
            
            // Update marker position
            if (targetIndex < route.coordinates.length) {
                const newPos = route.coordinates[targetIndex];
                route.animationMarker.setPosition(newPos);
                state.currentIndex = targetIndex;
                
                // Continue animation
                requestAnimationFrame(() => animateRoute(index));
            } else {
                // Animation complete
                console.log(`Animation complete for ${route.displayName}`);
                stopRouteAnimation(index);
                updateFileList();
            }
        }

        function fitMapToRoutes() {
            const visibleRoutes = routes.filter(r => r.visible);
            if (visibleRoutes.length === 0) return;

            const bounds = new google.maps.LatLngBounds();
            visibleRoutes.forEach(route => {
                route.coordinates.forEach(coord => {
                    bounds.extend(coord);
                });
            });
            
            map.fitBounds(bounds);
        }

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
            fileInput.value = '';
        });

        // Compact drop zone (always visible)
        const compactDropZone = document.getElementById('compactDropZone');
        const compactFileInput = document.getElementById('compactFileInput');

        compactDropZone.addEventListener('click', () => compactFileInput.click());

        compactDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            compactDropZone.classList.add('dragover');
        });

        compactDropZone.addEventListener('dragleave', () => {
            compactDropZone.classList.remove('dragover');
        });

        compactDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            compactDropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        compactFileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
            compactFileInput.value = '';
        });

        document.getElementById('compareBtn').addEventListener('click', toggleCompareMode);

        document.getElementById('sidebarToggle').addEventListener('click', function() {
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('sidebarToggle');
            sidebar.classList.toggle('collapsed');
            
            if (sidebar.classList.contains('collapsed')) {
                toggle.textContent = '▶';
                toggle.title = 'Show sidebar';
            } else {
                toggle.textContent = '◀';
                toggle.title = 'Hide sidebar';
            }
            
            setTimeout(() => {
                google.maps.event.trigger(map, 'resize');
                if (routes.length > 0) {
                    fitMapToRoutes();
                }
            }, 300);
        });

        window.initMap = initMap;

        // Speed slider with logarithmic scaling (1x to 1000x)
const speedSlider = document.getElementById('speedSlider');
const speedDisplay = document.getElementById('speedDisplay');

speedSlider.addEventListener('input', function() {
    const sliderValue = parseFloat(this.value);
    // Logarithmic scale: 1x at 0, 1000x at 100
    const speed = Math.pow(10, sliderValue * 3 / 100); // 0->1, 33.33->10, 66.67->100, 100->1000
    window.playbackSpeed = speed;
    
    // Format display
    if (speed >= 100) {
        speedDisplay.textContent = Math.round(speed) + 'x';
    } else if (speed >= 10) {
        speedDisplay.textContent = speed.toFixed(0) + 'x';
    } else {
        speedDisplay.textContent = speed.toFixed(1) + 'x';
    }
    
    // Update slider background gradient
    const percentage = (sliderValue / 100) * 100;
    this.style.background = `linear-gradient(to right, #1a73e8 0%, #1a73e8 ${percentage}%, #e0e0e0 ${percentage}%, #e0e0e0 100%)`;
});

// Initialize slider appearance
speedSlider.style.background = 'linear-gradient(to right, #1a73e8 0%, #1a73e8 0%, #e0e0e0 0%, #e0e0e0 100%)';
    </script>

    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDHN981eBYt2fLPZqx-r7iwVVasKfA-738&callback=initMap" async defer></script>
</body>
</html>