<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX & FIT Route Overlay</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #header {
            background: #1a73e8;
            color: white;
            padding: 12px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        #header h1 {
            font-size: 20px;
            font-weight: 500;
        }
        #header h1::after {
            content: " v4 [GPS FIXED]";
            font-size: 12px;
            background: #34a853;
            padding: 2px 8px;
            border-radius: 4px;
            margin-left: 10px;
            font-weight: 600;
        }
        #mainContainer {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        #sidebar {
            width: 320px;
            background: #f8f9fa;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s ease;
            position: relative;
            z-index: 100;
        }
        #sidebar.collapsed {
            margin-left: -320px;
        }
        #sidebarToggle {
            position: absolute;
            right: -40px;
            top: 80px;
            width: 40px;
            height: 40px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            z-index: 101;
        }
        #sidebarToggle:hover {
            background: #1557b0;
        }
        #sidebarHeader {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
        }
        #sidebarHeader h2 {
            font-size: 16px;
            color: #333;
            margin-bottom: 10px;
        }
        #compareBtn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            width: 100%;
            transition: all 0.2s;
        }
        #compareBtn:hover {
            background: #1557b0;
        }
        #compareBtn.active {
            background: #34a853;
        }       
        #compactDropZone {
            border: 2px dashed #ccc;
            border-radius: 6px;
            padding: 12px 10px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.2s;
        }
        #compactDropZone.dragover {
            border-color: #1a73e8;
            background: #e8f0fe;
        }
        #compactDropZone p {
            color: #5f6368;
            font-size: 12px;
            margin: 0;
        }
        #compactDropZone input {
            display: none; 
        }
        #compactDropZone.hidden {
            display: none;
        }
        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px 20px;
            margin: 15px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        #dropZone.dragover {
            border-color: #1a73e8;
            background: #e8f0fe;
        }
        #dropZone p {
            color: #5f6368;
            font-size: 14px;
            margin-bottom: 8px;
        }
        #dropZone input {
            display: none;
        }
        #fileList {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #fileList::-webkit-scrollbar {
            width: 8px;
        }
        #fileList::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #fileList::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        #fileList::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .file-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }
        .file-item:hover {
            border-color: #1a73e8;
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.15);
        }
        .file-item.highlighted {
            border-color: #1a73e8;
            background: #e8f0fe;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.3);
        }
        .file-item.selected {
            border-color: #ffc107;
            background: #fff8e1;
        }
        .compare-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            display: none;
        }
        .compare-mode .compare-checkbox {
            display: block;
        }
        .file-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .file-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }
        .file-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #ddd;
            flex-shrink: 0;
        }
        .file-name-container {
            flex: 1;
            margin-bottom: 8px;
        }
        .file-display-name {
            font-size: 14px;
            font-weight: 600;
            padding: 4px 6px;
            border-radius: 4px;
            width: 100%;
            border: 1px solid transparent;
            background: #f8f9fa;
            word-wrap: break-word;
            min-height: 28px;
            display: flex;
            align-items: center;
        }
        .file-display-name:hover {
            border-color: #e0e0e0;
        }
        .file-display-name:focus {
            outline: none;
            border-color: #1a73e8;
            background: white;
        }
        .file-original-name {
            font-size: 10px;
            color: #666;
            padding: 2px 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .file-stats {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 6px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid #e8e8e8;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #666;
            font-weight: 500;
        }
        .stat-value {
            font-weight: 600;
            color: #1a73e8;
        }
        .file-actions {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .file-play {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            flex: 1;
            font-weight: 500;
        }
        .file-play:hover {
            background: #1557b0;
        }
        .file-play.playing {
            background: #ea4335;
        }
        .file-toggle {
            background: #34a853;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            flex: 1;
            font-weight: 500;
        }
        .file-toggle.hidden-route {
            background: #999;
        }
        .file-toggle:hover {
            opacity: 0.8;
        }
        .file-remove {
            background: #ea4335;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            flex: 1;
            font-weight: 500;
        }
        .file-remove:hover {
            background: #d33828;
        }
        #mapContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        #map {
            flex: 1;
            width: 100%;
        }
        .hidden {
            display: none !important;
        }
        #routeTooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: nowrap;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(26, 115, 232, 0.2);
            line-height: 1.6;
        }
        #routeTooltip strong {
            color: #1a73e8;
            font-weight: 600;
        }
        #chartCrosshair {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 9999;
            display: none;
            white-space: nowrap;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(26, 115, 232, 0.2);
            max-width: 300px;
        }
        #chartCrosshair .crosshair-distance {
            font-weight: 600;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e0e0e0;
            color: #1a73e8;
        }
        #chartCrosshair .crosshair-route {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }
        #chartCrosshair .crosshair-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        #chartCrosshair .crosshair-value {
            font-weight: 600;
        }
        #playbackControls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 150;
            display: none;
            align-items: center;
            gap: 10px;
        }
        #playbackControls.show {
            display: flex;
        }
        .speed-btn {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .speed-btn:hover {
            background: #e8f0fe;
            border-color: #1a73e8;
        }
        .speed-btn.active {
            background: #1a73e8;
            color: white;
            border-color: #1a73e8;
        }
        .speed-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        #comparisonPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 2px solid #1a73e8;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.15);
            z-index: 200;
            max-height: 50vh;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        #comparisonPanel.show {
            transform: translateY(0);
        }
        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
        }
        .comparison-header h3 {
            color: #1a73e8;
            font-size: 16px;
            font-weight: 600;
        }
        .comparison-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .comparison-elevation-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .comparison-elevation-btn:hover {
            background: #1557b0;
        }
        .comparison-elevation-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .comparison-close {
            background: #ea4335;
            color: white;
            border: none;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .comparison-close:hover {
            background: #d33828;
        }
        .comparison-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px 20px;
        }
        .comparison-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .comparison-content::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .comparison-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .comparison-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #5f6368;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .route-name-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .route-color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        #elevationModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        #elevationModal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 90%;
            width: 1000px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        .modal-header h2 {
            font-size: 18px;
            color: #1a73e8;
            font-weight: 600;
        }
        .modal-close {
            background: #ea4335;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        .modal-close:hover {
            background: #d33828;
        }
        #elevationChart {
            width: 100%;
            height: 400px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: crosshair;
        }
        #elevationChart.drag-mode {
            cursor: grab;
        }
        #elevationChart.dragging {
            cursor: grabbing;
        }
        .chart-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .chart-control-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .chart-control-btn:hover {
            background: #1557b0;
        }
        .chart-control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .chart-control-btn.active {
            background: #34a853;
        }
        .chart-legend {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .legend-item:hover {
            background: #e8f0fe;
        }
        .legend-item.active {
            background: #e8f0fe;
            box-shadow: 0 0 0 2px #1a73e8;
        }
        .legend-color {
            width: 30px;
            height: 3px;
            margin-right: 8px;
        }
        .legend-label {
            font-size: 13px;
            color: #333;
        }
        .legend-offset {
            font-size: 11px;
            color: #666;
            margin-left: 8px;
            font-style: italic;
        }
        #speedSlider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #e0e0e0 0%, #1a73e8 0%);
            outline: none;
        }
        #speedSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1a73e8;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        #speedSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1a73e8;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Insights Modal Styles */
        #insightsModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        #insightsModal.show {
            display: flex;
        }
        .insights-modal-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 95%;
            width: 1100px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .insights-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        .insights-modal-header h2 {
            font-size: 18px;
            color: #1a73e8;
            font-weight: 600;
        }
        .insights-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            overflow-x: auto;
            flex-wrap: wrap;
        }
        .insights-tab {
            background: transparent;
            border: none;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #5f6368;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .insights-tab:hover {
            background: #f8f9fa;
            color: #1a73e8;
        }
        .insights-tab.active {
            color: #1a73e8;
            border-bottom-color: #1a73e8;
        }
        .insights-content {
            min-height: 500px;
            max-height: 500px;
            overflow-y: auto;
        }
        .insights-tab-panel {
            display: none;
            height: 100%;
            overflow-y: auto;
        }
        .insights-tab-panel.active {
            display: block;
        }
        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 15px;
            margin-top: 10px;
            padding-bottom: 10px;
        }
        .insight-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 16px;
            color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .insight-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .insight-card.positive {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        .insight-card.negative {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
        }
        .insight-card.neutral {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        .insight-card.warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .insight-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }
        .insight-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
            opacity: 0.95;
        }
        .insight-value {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 6px;
        }
        .insight-description {
            font-size: 13px;
            opacity: 0.9;
            line-height: 1.4;
        }
        
        .metric-insights-text {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px 24px;
            margin-top: 20px;
            line-height: 1.8;
            color: #2c3e50;
            border-left: 4px solid #4facfe;
        }
        
        .metric-insights-text p {
            margin: 0 0 16px 0;
            font-size: 14px;
        }
        
        .metric-insights-text p:last-child {
            margin-bottom: 0;
        }
        
        .metric-insights-text strong {
            color: #1a73e8;
            font-weight: 600;
        }
        
        .metric-insights-text em {
            color: #666;
            font-style: normal;
            font-size: 13px;
        }
        
        #insightsChart {
            width: 100%;
            height: 400px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: crosshair;
        }
        #insightsChart.drag-mode {
            cursor: grab;
        }
        #insightsChart.dragging {
            cursor: grabbing;
        }
        #insightsCrosshair {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 9999;
            display: none;
            white-space: nowrap;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(26, 115, 232, 0.2);
            max-width: 300px;
        }
        #insightsCrosshair .crosshair-distance {
            font-weight: 600;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e0e0e0;
            color: #1a73e8;
        }
        #insightsCrosshair .crosshair-route {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }
        #insightsCrosshair .crosshair-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        #insightsCrosshair .crosshair-value {
            font-weight: 600;
        }
        .insights-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .insights-btn:hover {
            background: #1557b0;
        }
        
        /* Firebase Authentication UI */
        #authContainer {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }
        #authButton {
            background: white;
            color: #1a73e8;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        #authButton:hover {
            background: #f1f3f4;
        }
        #userInfo {
            display: none;
            align-items: center;
            gap: 12px;
            color: white;
        }
        #userInfo.visible {
            display: flex;
        }
        #userAvatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid white;
        }
        #userName {
            font-size: 14px;
            font-weight: 500;
        }
        #signOutBtn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        #signOutBtn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }
        
        /* Saved Routes Section */
        #savedRoutesSection {
            display: none;
            padding: 15px;
            background: #e8f0fe;
            border-bottom: 1px solid #1a73e8;
        }
        #savedRoutesSection.visible {
            display: block;
        }
        #savedRoutesSection h3 {
            font-size: 14px;
            color: #1a73e8;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #savedRoutesList {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        .saved-route-item {
            background: white;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #dadce0;
        }
        .saved-route-item:hover {
            background: #f8f9fa;
            border-color: #1a73e8;
        }
        .saved-route-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .saved-route-name {
            font-weight: 500;
            font-size: 13px;
            color: #202124;
        }
        .saved-route-meta {
            font-size: 11px;
            color: #5f6368;
        }
        .saved-route-actions {
            display: flex;
            gap: 8px;
        }
        .saved-route-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .saved-route-btn:hover {
            background: #1557b0;
        }
        .saved-route-btn.delete {
            background: #ea4335;
        }
        .saved-route-btn.delete:hover {
            background: #c5221f;
        }
        #saveCurrentBtn {
            background: #34a853;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            width: 100%;
            margin-top: 10px;
            transition: all 0.2s;
            display: none;
        }
        #saveCurrentBtn.visible {
            display: block;
        }
        #saveCurrentBtn:hover {
            background: #2d8e47;
        }
        #saveCurrentBtn:disabled {
            background: #dadce0;
            cursor: not-allowed;
        }
        .loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #1a73e8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    
    </style>
</head>
<body>
    <div id="header">
        <div class="header-content">
            <h1>🗺️ GPX & FIT Route Overlay</h1>
            <div id="authContainer">
                <button id="authButton">
                    <span>🔐 Sign In with Google</span>
                </button>
                <div id="userInfo">
                    <img id="userAvatar" src="" alt="User">
                    <span id="userName"></span>
                    <button id="signOutBtn">Sign Out</button>
                </div>
            </div>
        </div>
    </div>
    <div id="mainContainer">
        <div id="sidebar">
            <button id="sidebarToggle" title="Toggle sidebar">◀</button>
            
            <!-- Saved Routes Section (shown when logged in) -->
            <div id="savedRoutesSection">
                <h3>☁️ My Saved Routes</h3>
                <div id="savedRoutesList"></div>
                <button id="saveCurrentBtn">💾 Save Current Routes</button>
            </div>
            
            <div id="sidebarHeader">
                <h2>📂 Routes</h2>
                <button id="compareBtn">📊 Compare Routes</button>
                <div id="compactDropZone" class="hidden">
                    <p>➕ Add more routes</p>
                    <p style="font-size: 11px; color: #666; margin-top: 4px;">💡 FIT files are more accurate</p>
                    <input type="file" id="compactFileInput" accept=".gpx,.fit" multiple>
                </div>
            </div>
            <div id="dropZone">
                <p>📂 Drag and drop GPX or FIT files</p>
                <p style="font-size: 12px; color: #999;">or click to browse</p>
                <p style="font-size: 11px; color: #666; margin-top: 8px;">💡 Tip: FIT files from your device provide more accurate data than exported GPX files</p>
                <input type="file" id="fileInput" accept=".gpx,.fit" multiple>
            </div>
            <div id="fileList" class="hidden"></div>
        </div>
        <div id="mapContainer">
            <div id="map"></div>
        </div>
    </div>
    <div id="comparisonPanel">
        <div class="comparison-header">
            <h3>📊 Route Comparison</h3>
            <div class="comparison-actions">
                <button class="comparison-elevation-btn" data-metric="elevation">📈 Elevation</button>
                <button class="comparison-elevation-btn" data-metric="speed">🏃 Speed</button>
                <button class="comparison-elevation-btn" data-metric="pace">⏱️ Pace</button>
                <button class="comparison-elevation-btn" data-metric="heartrate">❤️ Heart Rate</button>
                <button class="comparison-elevation-btn" data-metric="cadence">👟 Cadence</button>
                <button class="comparison-elevation-btn" data-metric="power">⚡ Power</button>
                <button class="comparison-close">Close</button>
            </div>
        </div>
        <div class="comparison-content">
            <table id="comparisonTableContent"></table>
        </div>
    </div>
    <div id="routeTooltip"></div>
    <div id="playbackControls">
        <span class="speed-label">Playback Speed:</span>
        <div style="display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 11px; color: #999;">1x</span>
            <input type="range" id="speedSlider" min="0" max="100" value="0" style="width: 200px;">
            <span style="font-size: 11px; color: #999;">1000x</span>
            <span id="speedDisplay" style="font-size: 13px; font-weight: 600; color: #1a73e8; min-width: 50px;">1x</span>
        </div>
    </div>
    <div id="elevationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Elevation Profile</h2>
                <button class="modal-close">Close</button>
            </div>
            <canvas id="elevationChart"></canvas>
            <div class="chart-controls">
                <button class="chart-control-btn" id="dragModeBtn">✋ Drag to Align</button>
                <button class="chart-control-btn" id="resetZoomBtn" disabled>🔍 Reset Zoom</button>
                <button class="chart-control-btn" id="resetOffsetsBtn" disabled>↺ Reset Offsets</button>
                <span id="zoomInstructions" style="color: #666; font-size: 12px;">Click and drag to zoom into a region</span>
            </div>
            <div id="chartLegend" class="chart-legend"></div>
        </div>
    </div>
    <div id="chartCrosshair"></div>

    <!-- Insights Modal -->
    <div id="insightsModal">
        <div class="insights-modal-content">
            <div class="insights-modal-header">
                <h2 id="insightsModalTitle">Run Insights</h2>
                <button class="modal-close" id="closeInsightsModal">Close</button>
            </div>
            <div class="insights-tabs">
                <button class="insights-tab active" data-tab="insights">💡 Insights</button>
                <button class="insights-tab" data-tab="elevation" style="display:none;">📈 Elevation</button>
                <button class="insights-tab" data-tab="grade" style="display:none;">📊 Grade</button>
                <button class="insights-tab" data-tab="speed" style="display:none;">🏃 Speed</button>
                <button class="insights-tab" data-tab="pace" style="display:none;">⏱️ Pace</button>
                <button class="insights-tab" data-tab="heartrate" style="display:none;">❤️ Heart Rate</button>
                <button class="insights-tab" data-tab="cadence" style="display:none;">👟 Cadence</button>
                <button class="insights-tab" data-tab="power" style="display:none;">⚡ Power</button>
            </div>
            <div class="insights-content">
                <div id="insightsTabContent" class="insights-tab-panel active">
                    <!-- Insights will be populated here -->
                </div>
                <div id="graphTabContent" class="insights-tab-panel">
                    <canvas id="insightsChart"></canvas>
                    <div class="chart-controls">
                        <button class="chart-control-btn" id="insightsResetZoomBtn" disabled>🔍 Reset Zoom</button>
                        <span id="insightsZoomInstructions" style="color: #666; font-size: 12px;">Click and drag to zoom into a region</span>
                    </div>
                    <div id="insightsChartLegend" class="chart-legend" style="display: none;"></div>
                    <div id="metricSpecificInsights" style="margin-top: 20px;">
                        <!-- Metric-specific insights will appear here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="insightsCrosshair"></div>

    <script type="module">
        import FitParserModule from 'https://esm.run/fit-file-parser@1.21.0';
        window.FitParser = FitParserModule.default || FitParserModule;
        window.fitParserReady = true;
        window.dispatchEvent(new Event('fitParserLoaded'));
    </script>

    <script>
        // ============================================================================
        // FIREBASE CONFIGURATION & AUTHENTICATION
        // ============================================================================
        
        // Firebase Configuration - REPLACE THESE WITH YOUR FIREBASE PROJECT VALUES
        const firebaseConfig = {
            apiKey: "AIzaSyB5wxDcFNEdmhrmyZqpVW30mC460kHUzs8",
            authDomain: "gps-route-overlay.firebaseapp.com",
            projectId: "gps-route-overlay",
            storageBucket: "Ygps-route-overlay.firebasestorage.app",
            messagingSenderId: "910323096205",
            appId: "1:910323096205:web:ee740787d7aeffa5b820c4"
        };
        
        // Initialize Firebase
        let firebaseApp, auth, db, storage;
        let firebaseInitialized = false;
        
        function initializeFirebase() {
            try {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                storage = firebase.storage();
                firebaseInitialized = true;
                console.log('✅ Firebase initialized successfully');
                return true;
            } catch (error) {
                console.warn('⚠️ Firebase initialization failed:', error.message);
                console.log('ℹ️ App will work without cloud sync features');
                return false;
            }
        }
        
        // Firebase Authentication Manager
        class FirebaseAuthManager {
            constructor() {
                this.currentUser = null;
                this.onAuthStateChangedCallback = null;
            }
            
            async signInWithGoogle() {
                if (!firebaseInitialized) {
                    alert('Firebase not configured. Please add your Firebase credentials.');
                    return null;
                }
                
                try {
                    const provider = new firebase.auth.GoogleAuthProvider();
                    const result = await auth.signInWithPopup(provider);
                    this.currentUser = result.user;
                    console.log('✅ Signed in:', result.user.displayName);
                    return result.user;
                } catch (error) {
                    console.error('❌ Sign in error:', error);
                    alert('Sign in failed: ' + error.message);
                    return null;
                }
            }
            
            async signOut() {
                if (!firebaseInitialized) return;
                
                try {
                    await auth.signOut();
                    this.currentUser = null;
                    console.log('✅ Signed out');
                } catch (error) {
                    console.error('❌ Sign out error:', error);
                }
            }
            
            onAuthStateChanged(callback) {
                if (!firebaseInitialized) return;
                
                this.onAuthStateChangedCallback = callback;
                auth.onAuthStateChanged((user) => {
                    this.currentUser = user;
                    callback(user);
                });
            }
            
            getCurrentUser() {
                return this.currentUser;
            }
        }
        
        // Firebase Storage Manager for Routes
        class FirebaseStorageManager {
            constructor() {
                this.userId = null;
            }
            
            setUser(userId) {
                this.userId = userId;
            }
            
            async saveRoutes(routes, rawFiles) {
                if (!firebaseInitialized || !this.userId) {
                    console.warn('Cannot save: not logged in');
                    return false;
                }
                
                try {
                    // Create session document first to get session ID
                    const sessionRef = db.collection('users').doc(this.userId).collection('sessions').doc();
                    const sessionId = sessionRef.id;
                    
                    console.log('📤 Uploading files to Cloud Storage...');
                    
                    // Upload raw files to Cloud Storage
                    const fileMetadata = [];
                    for (let i = 0; i < rawFiles.length; i++) {
                        const file = rawFiles[i];
                        const route = routes[i];
                        
                        // Create storage path: users/{userId}/sessions/{sessionId}/{filename}
                        const storageRef = storage.ref(`users/${this.userId}/sessions/${sessionId}/${file.name}`);
                        
                        // Upload file
                        const uploadTask = await storageRef.put(file);
                        const downloadURL = await uploadTask.ref.getDownloadURL();
                        
                        fileMetadata.push({
                            fileName: file.name,
                            fileSize: file.size,
                            fileType: file.type,
                            displayName: route.displayName,
                            color: route.color,
                            distance: Math.round(route.distance * 100) / 100 || 0,
                            duration: Math.round(route.duration || 0),
                            elevationGain: Math.round(route.elevationStats?.gain || 0),
                            elevationLoss: Math.round(route.elevationStats?.loss || 0),
                            downloadURL: downloadURL,
                            storagePath: storageRef.fullPath
                        });
                        
                        console.log(`✅ Uploaded ${file.name} (${(file.size / 1024).toFixed(1)} KB)`);
                    }
                    
                    // Save session metadata to Firestore
                    await sessionRef.set({
                        files: fileMetadata,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        routeCount: routes.length,
                        totalSize: rawFiles.reduce((sum, f) => sum + f.size, 0)
                    });
                    
                    console.log(`✅ Session saved: ${sessionId}`);
                    return sessionId;
                } catch (error) {
                    console.error('❌ Save error:', error);
                    alert('Failed to save routes: ' + error.message);
                    return false;
                }
            }
            
            async getSavedSessions() {
                if (!firebaseInitialized || !this.userId) {
                    return [];
                }
                
                try {
                    const snapshot = await db.collection('users')
                        .doc(this.userId)
                        .collection('sessions')
                        .orderBy('createdAt', 'desc')
                        .limit(20)
                        .get();
                    
                    const sessions = [];
                    snapshot.forEach(doc => {
                        sessions.push({
                            id: doc.id,
                            ...doc.data()
                        });
                    });
                    
                    console.log(`✅ Loaded ${sessions.length} saved sessions`);
                    return sessions;
                } catch (error) {
                    console.error('❌ Load error:', error);
                    return [];
                }
            }
            
            async loadSession(sessionId) {
                if (!firebaseInitialized || !this.userId) {
                    return null;
                }
                
                try {
                    const doc = await db.collection('users')
                        .doc(this.userId)
                        .collection('sessions')
                        .doc(sessionId)
                        .get();
                    
                    if (!doc.exists) {
                        return null;
                    }
                    
                    const sessionData = doc.data();
                    console.log(`📥 Downloading ${sessionData.files.length} files from Cloud Storage...`);
                    
                    // Download and parse each file
                    const parsedRoutes = [];
                    for (const fileMetadata of sessionData.files) {
                        try {
                            // Download file from Cloud Storage
                            const storageRef = storage.ref(fileMetadata.storagePath);
                            const downloadURL = await storageRef.getDownloadURL();
                            
                            // Fetch file content
                            const response = await fetch(downloadURL);
                            
                            const isGPX = fileMetadata.fileName.toLowerCase().endsWith('.gpx');
                            const isFIT = fileMetadata.fileName.toLowerCase().endsWith('.fit');
                            
                            if (isGPX) {
                                const text = await response.text();
                                const routeData = FileParser.parseGPX(text, fileMetadata.color, fileMetadata.fileName);
                                routeData.displayName = fileMetadata.displayName;
                                parsedRoutes.push(routeData);
                                console.log(`✅ Downloaded and parsed ${fileMetadata.fileName}`);
                            } else if (isFIT) {
                                const arrayBuffer = await response.arrayBuffer();
                                const routeData = await FileParser.parseFIT(arrayBuffer, fileMetadata.color, fileMetadata.fileName);
                                routeData.displayName = fileMetadata.displayName;
                                parsedRoutes.push(routeData);
                                console.log(`✅ Downloaded and parsed ${fileMetadata.fileName}`);
                            }
                        } catch (error) {
                            console.error(`❌ Error loading ${fileMetadata.fileName}:`, error);
                        }
                    }
                    
                    console.log(`✅ Session loaded: ${sessionId}`);
                    return { routes: parsedRoutes };
                } catch (error) {
                    console.error('❌ Load session error:', error);
                    return null;
                }
            }
            
            async deleteSession(sessionId) {
                if (!firebaseInitialized || !this.userId) {
                    return false;
                }
                
                try {
                    // Get session data to find storage paths
                    const doc = await db.collection('users')
                        .doc(this.userId)
                        .collection('sessions')
                        .doc(sessionId)
                        .get();
                    
                    if (doc.exists) {
                        const sessionData = doc.data();
                        
                        // Delete files from Cloud Storage
                        if (sessionData.files) {
                            for (const fileMetadata of sessionData.files) {
                                try {
                                    const storageRef = storage.ref(fileMetadata.storagePath);
                                    await storageRef.delete();
                                    console.log(`🗑️ Deleted ${fileMetadata.fileName} from storage`);
                                } catch (error) {
                                    console.warn(`⚠️ Could not delete ${fileMetadata.fileName}:`, error.message);
                                }
                            }
                        }
                    }
                    
                    // Delete Firestore document
                    await db.collection('users')
                        .doc(this.userId)
                        .collection('sessions')
                        .doc(sessionId)
                        .delete();
                    
                    console.log('✅ Session deleted:', sessionId);
                    return true;
                } catch (error) {
                    console.error('❌ Delete error:', error);
                    return false;
                }
            }
        }
        
        // Initialize Firebase (will fail gracefully if not configured)
        initializeFirebase();
        
        // Create global instances
        const authManager = new FirebaseAuthManager();
        const storageManager = new FirebaseStorageManager();
        
        // ============================================================================
        // UTILITY CLASSES AND FUNCTIONS
        // ============================================================================
        
        const Utils = {
            colors: [
                '#EA4335', '#4285F4', '#FBBC04', '#34A853', '#FF6D00', '#46BDC6', 
                '#7B1FA2', '#C2185B', '#00BCD4', '#8BC34A', '#FF5722', '#9C27B0',
                '#03A9F4', '#FFEB3B', '#E91E63', '#00ACC1', '#7CB342', '#F57C00',
                '#5E35B1', '#D81B60'
            ],
            
            haversineDistance(coord1, coord2) {
                const R = 6371;
                const dLat = this.toRad(coord2.lat - coord1.lat);
                const dLon = this.toRad(coord2.lng - coord1.lng);
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(this.toRad(coord1.lat)) * Math.cos(this.toRad(coord2.lat)) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            },
            
            toRad(deg) {
                return deg * (Math.PI / 180);
            },
            
            calculateDistance(coords) {
                let totalDistance = 0;
                for (let i = 1; i < coords.length; i++) {
                    totalDistance += this.haversineDistance(coords[i-1], coords[i]);
                }
                return totalDistance;
            },
            
            calculateElevationStats(elevations) {
                if (!elevations || elevations.length === 0) {
                    return { gain: 0, loss: 0, min: 0, max: 0 };
                }
                
                // Filter out nulls for statistics
                const validElevations = elevations.filter(e => e !== null && !isNaN(e));
                if (validElevations.length === 0) {
                    return { gain: 0, loss: 0, min: 0, max: 0 };
                }
                
                let gain = 0, loss = 0;
                let min = validElevations[0], max = validElevations[0];
                for (let i = 1; i < validElevations.length; i++) {
                    const diff = validElevations[i] - validElevations[i-1];
                    if (diff > 0) gain += diff;
                    else loss += Math.abs(diff);
                    if (validElevations[i] < min) min = validElevations[i];
                    if (validElevations[i] > max) max = validElevations[i];
                }
                return { gain, loss, min, max };
            },
            
            formatDistance(km) {
                return km >= 1 ? `${km.toFixed(2)} km` : `${(km * 1000).toFixed(0)} m`;
            },
            
            formatElevation(m) {
                return `${Math.round(m)} m`;
            },
            
            formatDuration(seconds) {
                if (!seconds) return 'N/A';
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.round(seconds % 60);
                if (hours > 0) {
                    return `${hours}h ${mins}m`;
                } else if (mins > 0) {
                    return `${mins}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            },
            
            formatBreakDuration(seconds) {
                if (!seconds) return 'N/A';
                if (seconds < 60) {
                    return `${Math.round(seconds)} seconds`;
                } else {
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.round(seconds % 60);
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }
            },
            
            formatHeartRate(bpm) {
                return (!bpm || isNaN(bpm)) ? 'N/A' : `${Math.round(bpm)} bpm`;
            },
            
            formatPace(minPerKm) {
                if (minPerKm === null || minPerKm === undefined || isNaN(minPerKm) || !isFinite(minPerKm) || minPerKm <= 0 || minPerKm > 20) {
                    return 'N/A';
                }
                const mins = Math.floor(minPerKm);
                const secs = Math.round((minPerKm - mins) * 60);
                return `${mins}:${secs.toString().padStart(2, '0')} /km`;
            },
            
            formatCadence(spm) {
                return (!spm || isNaN(spm)) ? 'N/A' : `${Math.round(spm)} spm`;
            },
            
            smoothData(data, windowSize = 20) {
                if (data.length < windowSize) return data;
                const smoothed = [];
                for (let i = 0; i < data.length; i++) {
                    const start = Math.max(0, i - Math.floor(windowSize / 2));
                    const end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                    let sum = 0, count = 0;
                    for (let j = start; j < end; j++) {
                        if (data[j] !== null && data[j] !== undefined) {
                            sum += data[j];
                            count++;
                        }
                    }
                    smoothed.push(count > 0 ? sum / count : data[i]);
                }
                return smoothed;
            },
            
            decimateData(data, distances, factor = 20) {
                if (data.length <= factor * 2) return { data, distances };
                const decimatedData = [data[0]];
                const decimatedDistances = [distances[0]];
                for (let i = factor; i < data.length - 1; i += factor) {
                    decimatedData.push(data[i]);
                    decimatedDistances.push(distances[i]);
                }
                decimatedData.push(data[data.length - 1]);
                decimatedDistances.push(distances[distances.length - 1]);
                return { data: decimatedData, distances: decimatedDistances };
            },
            
            getAdaptiveSmoothingParams(totalDistanceKm) {
                if (totalDistanceKm < 10) return { windowSize: 50, decimationFactor: 5 };
                if (totalDistanceKm < 25) return { windowSize: 100, decimationFactor: 10 };
                if (totalDistanceKm < 50) return { windowSize: 200, decimationFactor: 15 };
                if (totalDistanceKm < 100) return { windowSize: 300, decimationFactor: 25 };
                return { windowSize: 500, decimationFactor: 50 };
            },
            
            // ========================================================================
            // ADVANCED GPS FILTERING FUNCTIONS
            // ========================================================================
            
            /**
             * Calculate median of an array
             */
            median(arr) {
                if (!arr || arr.length === 0) return null;
                const sorted = [...arr].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 === 0 
                    ? (sorted[mid - 1] + sorted[mid]) / 2 
                    : sorted[mid];
            },
            
            /**
             * Calculate Median Absolute Deviation (MAD) - robust outlier detection
             */
            calculateMAD(arr) {
                if (!arr || arr.length === 0) return { median: null, mad: null };
                const med = this.median(arr);
                const deviations = arr.map(val => Math.abs(val - med));
                const mad = this.median(deviations);
                return { median: med, mad: mad };
            },
            
            /**
             * Filter outliers using Interquartile Range (IQR) method
             */
            filterOutliersIQR(data, multiplier = 1.5) {
                if (!data || data.length < 4) return data;
                
                const sorted = [...data].sort((a, b) => a - b);
                const q1Index = Math.floor(sorted.length * 0.25);
                const q3Index = Math.floor(sorted.length * 0.75);
                const q1 = sorted[q1Index];
                const q3 = sorted[q3Index];
                const iqr = q3 - q1;
                
                const lowerBound = q1 - (multiplier * iqr);
                const upperBound = q3 + (multiplier * iqr);
                
                return data.filter(val => val >= lowerBound && val <= upperBound);
            },
            
            /**
             * Filter outliers using MAD method (more robust than IQR)
             */
            filterOutliersMAD(data, threshold = 3) {
                if (!data || data.length < 4) return data;
                
                const { median, mad } = this.calculateMAD(data);
                if (mad === 0) return data; // All values are the same
                
                // Modified Z-score using MAD
                return data.filter(val => {
                    const modifiedZScore = 0.6745 * Math.abs(val - median) / mad;
                    return modifiedZScore <= threshold;
                });
            },
            
            /**
             * Detect acceleration spikes between consecutive speed measurements
             */
            filterAccelerationSpikes(speeds, timestamps, maxAcceleration = 10) {
                if (!speeds || !timestamps || speeds.length < 2) return speeds;
                
                const filtered = [speeds[0]];
                
                for (let i = 1; i < speeds.length; i++) {
                    if (!speeds[i] || !speeds[i-1] || !timestamps[i] || !timestamps[i-1]) {
                        filtered.push(speeds[i]);
                        continue;
                    }
                    
                    const deltaSpeed = Math.abs(speeds[i] - speeds[i-1]) * (1000/3600); // Convert km/h to m/s
                    const deltaTime = (timestamps[i] - timestamps[i-1]) / 1000; // Convert to seconds
                    
                    if (deltaTime > 0) {
                        const acceleration = deltaSpeed / deltaTime;
                        
                        // If acceleration is unrealistic, skip this point
                        if (acceleration > maxAcceleration) {
                            filtered.push(null); // Mark as invalid
                            continue;
                        }
                    }
                    
                    filtered.push(speeds[i]);
                }
                
                return filtered;
            },
            
            /**
             * Detect distance jumps (GPS teleportation)
             */
            filterDistanceJumps(coordinates, timestamps, maxSpeedKmh = 35) {
                if (!coordinates || !timestamps || coordinates.length < 2) return coordinates.map(() => true);
                
                const validFlags = [true]; // First point is always valid
                
                for (let i = 1; i < coordinates.length; i++) {
                    if (!timestamps[i] || !timestamps[i-1]) {
                        validFlags.push(true);
                        continue;
                    }
                    
                    const distance = this.haversineDistance(coordinates[i-1], coordinates[i]) * 1000; // meters
                    const deltaTime = (timestamps[i] - timestamps[i-1]) / 1000; // seconds
                    
                    if (deltaTime > 0) {
                        const impliedSpeed = (distance / deltaTime) * 3.6; // km/h
                        
                        // If implied speed is impossible, mark as invalid
                        if (impliedSpeed > maxSpeedKmh) {
                            validFlags.push(false);
                            continue;
                        }
                    }
                    
                    validFlags.push(true);
                }
                
                return validFlags;
            },
            
            /**
             * Apply rolling median filter (more robust than mean for outliers)
             */
            rollingMedian(data, windowSize = 5) {
                if (!data || data.length < windowSize) return data;
                
                const result = [];
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < data.length; i++) {
                    const start = Math.max(0, i - halfWindow);
                    const end = Math.min(data.length, i + halfWindow + 1);
                    const window = data.slice(start, end).filter(v => v !== null && !isNaN(v));
                    
                    if (window.length > 0) {
                        result.push(this.median(window));
                    } else {
                        result.push(data[i]);
                    }
                }
                
                return result;
            },
            
            /**
             * Comprehensive GPS data cleaning pipeline
             */
            cleanGPSData(speeds, paces, coordinates, timestamps, maxSpeed = 30) {
                const cleaned = {
                    speeds: [...speeds],
                    paces: [...paces],
                    validIndices: []
                };
                
                // Step 1: Filter distance jumps
                const distanceFlags = this.filterDistanceJumps(coordinates, timestamps, maxSpeed);
                
                // Step 2: Filter acceleration spikes
                const accelFiltered = this.filterAccelerationSpikes(speeds, timestamps);
                
                // Step 3: Combine filters
                for (let i = 0; i < speeds.length; i++) {
                    if (!distanceFlags[i] || accelFiltered[i] === null) {
                        cleaned.speeds[i] = null;
                        cleaned.paces[i] = null;
                    } else if (speeds[i] > maxSpeed || speeds[i] < 0) {
                        cleaned.speeds[i] = null;
                        cleaned.paces[i] = null;
                    } else {
                        cleaned.validIndices.push(i);
                    }
                }
                
                return cleaned;
            }
        };

        // ============================================================================
        // ROUTE CLASS - Encapsulates route data and map objects
        // ============================================================================
        
        class Route {
            constructor(data) {
                this.id = Date.now() + Math.random();
                this.filename = data.filename;
                this.displayName = data.displayName || data.filename.replace(/\.(gpx|fit)$/i, '').replace(/_/g, ' ');
                this.color = data.color;
                this.coordinates = data.coordinates;
                this.elevations = data.elevations || [];
                this.heartRates = data.heartRates || [];
                this.cadences = data.cadences || [];
                this.powers = data.powers || [];
                this.speeds = data.speeds || [];
                this.paces = data.paces || [];
                this.timestamps = data.timestamps || [];
                this.stats = data.stats;
                this.visible = true;
                this.selected = false;
                this.isPlaying = false;
                
                // Map objects
                this.polyline = null;
                this.startMarker = null;
                this.animationMarker = null;
                
                // Animation state
                this.animationState = null;
            }
            
            createMapObjects(map, index, handlers) {
                this.polyline = new google.maps.Polyline({
                    path: this.coordinates,
                    geodesic: true,
                    strokeColor: this.color,
                    strokeOpacity: 1.0,
                    strokeWeight: 5,
                    map: map
                });

                this.startMarker = new google.maps.Marker({
                    position: this.coordinates[0],
                    map: map,
                    label: {
                        text: String(index + 1),
                        color: 'white',
                        fontWeight: 'bold',
                        fontSize: '12px'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 12,
                        fillColor: this.color,
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 2
                    },
                    zIndex: 1000
                });

                // Attach event handlers
                this.polyline.addListener('mouseover', (e) => handlers.onMouseOver(this, e));
                this.polyline.addListener('mousemove', (e) => handlers.onMouseMove(this, e));
                this.polyline.addListener('mouseout', () => handlers.onMouseOut());
                this.polyline.addListener('click', () => handlers.onClick(this));
            }
            
            setVisible(visible, map) {
                this.visible = visible;
                this.polyline.setMap(visible ? map : null);
                this.startMarker.setMap(visible ? map : null);
            }
            
            highlight(highlight) {
                if (highlight) {
                    this.polyline.setOptions({ strokeWeight: 8, strokeOpacity: 1.0 });
                } else {
                    this.polyline.setOptions({ strokeWeight: 5, strokeOpacity: 1.0 });
                }
            }
            
            getClosestPointInfo(latLng) {
                // Find the closest point on the route to the mouse position
                let minDistance = Infinity;
                let closestIndex = 0;
                
                for (let i = 0; i < this.coordinates.length; i++) {
                    const coord = this.coordinates[i];
                    const distance = google.maps.geometry.spherical.computeDistanceBetween(
                        new google.maps.LatLng(coord.lat, coord.lng),
                        latLng
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                // Calculate cumulative distance to this point
                let distanceToPoint = 0;
                for (let i = 1; i <= closestIndex; i++) {
                    const prev = this.coordinates[i - 1];
                    const curr = this.coordinates[i];
                    distanceToPoint += google.maps.geometry.spherical.computeDistanceBetween(
                        new google.maps.LatLng(prev.lat, prev.lng),
                        new google.maps.LatLng(curr.lat, curr.lng)
                    );
                }
                
                // Calculate elapsed time to this point
                let timeToPoint = null;
                if (this.timestamps.length > closestIndex && this.timestamps[0] && this.timestamps[closestIndex]) {
                    const startTime = this.timestamps[0];
                    const currentTime = this.timestamps[closestIndex];
                    timeToPoint = (currentTime - startTime) / 1000; // in seconds
                }
                
                return {
                    index: closestIndex,
                    distance: distanceToPoint, // in meters
                    time: timeToPoint
                };
            }
            
            destroy() {
                if (this.polyline) {
                    google.maps.event.clearInstanceListeners(this.polyline);
                    this.polyline.setMap(null);
                    this.polyline = null;
                }
                if (this.startMarker) {
                    this.startMarker.setMap(null);
                    this.startMarker = null;
                }
                if (this.animationMarker) {
                    this.animationMarker.setMap(null);
                    this.animationMarker = null;
                }
                this.animationState = null;
            }
        }

        // ============================================================================
        // MAP MANAGER - Handles map interactions
        // ============================================================================
        
        class MapManager {
            constructor(mapElement) {
                this.map = new google.maps.Map(mapElement, {
                    center: { lat: 40, lng: -100 },
                    zoom: 4,
                    mapTypeControl: true,
                    streetViewControl: false
                });
                this.tooltip = document.getElementById('routeTooltip');
            }
            
            fitToRoutes(routes) {
                const visibleRoutes = routes.filter(r => r.visible);
                if (visibleRoutes.length === 0) return;
                
                const bounds = new google.maps.LatLngBounds();
                visibleRoutes.forEach(route => {
                    route.coordinates.forEach(coord => bounds.extend(coord));
                });
                this.map.fitBounds(bounds);
            }
            
            showTooltip(text, latLng, distance, time) {
                // Build tooltip content
                let content = `<strong>${text}</strong>`;
                if (distance !== undefined) {
                    content += `<br>Distance: ${Utils.formatDistance(distance / 1000)}`; // distance is in meters, formatDistance expects km
                }
                if (time !== null && time !== undefined) {
                    content += `<br>Time: ${Utils.formatDuration(time)}`;
                }
                
                this.tooltip.innerHTML = content;
                this.tooltip.style.display = 'block';
                
                const projection = this.map.getProjection();
                const point = projection.fromLatLngToPoint(latLng);
                const scale = Math.pow(2, this.map.getZoom());
                const pixelOffset = new google.maps.Point(
                    Math.floor(point.x * scale),
                    Math.floor(point.y * scale)
                );
                
                const bounds = this.map.getBounds();
                const ne = bounds.getNorthEast();
                const sw = bounds.getSouthWest();
                const topRight = projection.fromLatLngToPoint(ne);
                const bottomLeft = projection.fromLatLngToPoint(sw);
                
                const x = (pixelOffset.x - bottomLeft.x * scale);
                const y = (pixelOffset.y - topRight.y * scale);
                
                const mapDiv = document.getElementById('map');
                const rect = mapDiv.getBoundingClientRect();
                
                this.tooltip.style.left = (rect.left + x + 10) + 'px';
                this.tooltip.style.top = (rect.top + y - 30) + 'px';
            }
            
            hideTooltip() {
                this.tooltip.style.display = 'none';
            }
        }

        // ============================================================================
        // ANIMATION MANAGER - Handles route playback
        // ============================================================================
        
        class AnimationManager {
            constructor(mapManager) {
                this.mapManager = mapManager;
                this.playbackSpeed = 1;
                this.activeAnimations = new Map();
                this.setupSpeedControl();
            }
            
            setupSpeedControl() {
                const slider = document.getElementById('speedSlider');
                const display = document.getElementById('speedDisplay');
                
                slider.addEventListener('input', () => {
                    const sliderValue = parseFloat(slider.value);
                    this.playbackSpeed = Math.pow(10, sliderValue * 3 / 100);
                    
                    if (this.playbackSpeed >= 100) {
                        display.textContent = Math.round(this.playbackSpeed) + 'x';
                    } else if (this.playbackSpeed >= 10) {
                        display.textContent = this.playbackSpeed.toFixed(0) + 'x';
                    } else {
                        display.textContent = this.playbackSpeed.toFixed(1) + 'x';
                    }
                    
                    const percentage = (sliderValue / 100) * 100;
                    slider.style.background = `linear-gradient(to right, #1a73e8 0%, #1a73e8 ${percentage}%, #e0e0e0 ${percentage}%, #e0e0e0 100%)`;
                });
            }
            
            start(route) {
                if (!route.timestamps || route.timestamps.length === 0) {
                    alert('No timestamp data available for animation');
                    return false;
                }
                
                if (!route.animationMarker) {
                    route.animationMarker = new google.maps.Marker({
                        position: route.coordinates[0],
                        map: this.mapManager.map,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 8,
                            fillColor: route.color,
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 3
                        },
                        zIndex: 2000
                    });
                } else {
                    route.animationMarker.setPosition(route.coordinates[0]);
                    route.animationMarker.setMap(this.mapManager.map);
                }
                
                route.isPlaying = true;
                route.animationState = {
                    currentIndex: 0,
                    startTime: Date.now(),
                    pauseTime: 0
                };
                
                this.activeAnimations.set(route.id, route);
                this.animate(route);
                
                document.getElementById('playbackControls').classList.add('show');
                return true;
            }
            
            stop(route) {
                route.isPlaying = false;
                if (route.animationMarker) {
                    route.animationMarker.setMap(null);
                }
                route.animationState = null;
                this.activeAnimations.delete(route.id);
                
                if (this.activeAnimations.size === 0) {
                    document.getElementById('playbackControls').classList.remove('show');
                }
            }
            
            animate(route) {
                if (!route.isPlaying || !route.animationState) return;
                
                const state = route.animationState;
                const elapsedMs = (Date.now() - state.startTime) * this.playbackSpeed;
                
                const firstValidTimestamp = route.timestamps.find(t => t !== null);
                if (!firstValidTimestamp) {
                    this.stop(route);
                    return;
                }
                
                const startTimestamp = firstValidTimestamp.getTime();
                let targetIndex = 0;
                
                for (let i = 0; i < route.timestamps.length; i++) {
                    if (route.timestamps[i]) {
                        const pointTime = route.timestamps[i].getTime() - startTimestamp;
                        if (pointTime <= elapsedMs) {
                            targetIndex = i;
                        } else {
                            break;
                        }
                    }
                }
                
                if (targetIndex < route.coordinates.length) {
                    route.animationMarker.setPosition(route.coordinates[targetIndex]);
                    state.currentIndex = targetIndex;
                    requestAnimationFrame(() => this.animate(route));
                } else {
                    this.stop(route);
                }
            }
            
            destroy() {
                this.activeAnimations.forEach(route => this.stop(route));
                this.activeAnimations.clear();
            }
        }

        // ============================================================================
        // CHART MANAGER - Handles elevation/metric charts
        // ============================================================================
        
        class ChartManager {
            constructor() {
                this.canvas = document.getElementById('elevationChart');
                this.ctx = this.canvas.getContext('2d');
                this.modal = document.getElementById('elevationModal');
                this.crosshair = document.getElementById('chartCrosshair');
                
                this.currentData = null;
                this.zoomState = null;
                this.dragMode = false;
                this.selectedRouteForDrag = null;
                this.routeOffsets = {};
                
                this.isDragging = false;
                this.isSelecting = false;
                this.dragStartX = null;
                this.dragStartOffset = 0;
                this.selectionStart = null;
                this.animationFrameId = null;
                this.originalImage = null;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Modal close
                this.modal.querySelector('.modal-close').addEventListener('click', () => this.close());
                
                // Chart controls
                document.getElementById('dragModeBtn').addEventListener('click', () => this.toggleDragMode());
                document.getElementById('resetZoomBtn').addEventListener('click', () => this.resetZoom());
                document.getElementById('resetOffsetsBtn').addEventListener('click', () => this.resetOffsets());
                
                // Canvas interactions
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
                this.canvas.addEventListener('mouseenter', () => this.handleMouseEnter());
            }
            
            show(routes, metricType, yAxisLabel, formatValue) {
                document.getElementById('modalTitle').textContent = 
                    `${yAxisLabel.split('(')[0].trim()} ${routes.length > 1 ? `Comparison (${routes.length} routes)` : `Profile: ${routes[0].displayName}`}`;
                this.modal.classList.add('show');
                this.drawChart(routes, metricType, yAxisLabel, formatValue);
            }
            
            close() {
                this.modal.classList.remove('show');
                this.zoomState = null;
                this.currentData = null;
                this.dragMode = false;
                this.selectedRouteForDrag = null;
                this.routeOffsets = {};
                this.isDragging = false;
                this.isSelecting = false;
                this.originalImage = null;
                
                document.getElementById('resetZoomBtn').disabled = true;
                document.getElementById('resetOffsetsBtn').disabled = true;
                document.getElementById('dragModeBtn').classList.remove('active');
                document.getElementById('dragModeBtn').textContent = '✋ Drag to Align';
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }
            
            toggleDragMode() {
                this.dragMode = !this.dragMode;
                const btn = document.getElementById('dragModeBtn');
                const instructions = document.getElementById('zoomInstructions');
                
                if (this.dragMode) {
                    btn.classList.add('active');
                    btn.textContent = '✋ Drag Mode Active';
                    this.canvas.classList.add('drag-mode');
                    instructions.textContent = 'Click a route in the legend, then drag it horizontally to align';
                } else {
                    btn.classList.remove('active');
                    btn.textContent = '✋ Drag to Align';
                    this.canvas.classList.remove('drag-mode');
                    this.selectedRouteForDrag = null;
                    instructions.textContent = 'Click and drag to zoom into a region';
                }
                this.updateLegend();
            }
            
            resetZoom() {
                this.zoomState = null;
                document.getElementById('resetZoomBtn').disabled = true;
                if (this.currentData) {
                    this.drawChart(
                        this.currentData.routes,
                        this.currentData.metricType,
                        this.currentData.yAxisLabel,
                        this.currentData.formatValue
                    );
                }
            }
            
            resetOffsets() {
                this.routeOffsets = {};
                document.getElementById('resetOffsetsBtn').disabled = true;
                if (this.currentData) {
                    this.drawChart(
                        this.currentData.routes,
                        this.currentData.metricType,
                        this.currentData.yAxisLabel,
                        this.currentData.formatValue
                    );
                }
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const chartWidth = this.canvas.width - 140;
                
                if (x >= 70 && x <= 70 + chartWidth) {
                    if (this.dragMode && this.selectedRouteForDrag !== null) {
                        this.isDragging = true;
                        this.dragStartX = x;
                        const routeId = this.currentData.routes[this.selectedRouteForDrag].filename;
                        this.dragStartOffset = this.routeOffsets[routeId] || 0;
                        this.canvas.classList.add('dragging');
                    } else if (!this.dragMode) {
                        this.isSelecting = true;
                        const y = e.clientY - rect.top;
                        this.selectionStart = { x, y };
                    }
                }
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const chartWidth = this.canvas.width - 140;
                const chartHeight = this.canvas.height - 120;
                
                if (this.isDragging && this.selectedRouteForDrag !== null) {
                    const pixelDiff = x - this.dragStartX;
                    const maxDistance = Math.max(...this.currentData.routes.map(r => {
                        const offset = this.routeOffsets[r.filename] || 0;
                        return r.stats.distance + offset;
                    }));
                    const distanceDiff = (pixelDiff / chartWidth) * maxDistance;
                    const routeId = this.currentData.routes[this.selectedRouteForDrag].filename;
                    this.routeOffsets[routeId] = this.dragStartOffset + distanceDiff;
                    
                    document.getElementById('resetOffsetsBtn').disabled = false;
                    
                    if (!this.animationFrameId) {
                        this.animationFrameId = requestAnimationFrame(() => {
                            if (this.currentData) {
                                this.drawChart(
                                    this.currentData.routes,
                                    this.currentData.metricType,
                                    this.currentData.yAxisLabel,
                                    this.currentData.formatValue
                                );
                            }
                            this.animationFrameId = null;
                        });
                    }
                } else if (this.isSelecting && this.selectionStart) {
                    if (this.currentData) {
                        this.drawChart(
                            this.currentData.routes,
                            this.currentData.metricType,
                            this.currentData.yAxisLabel,
                            this.currentData.formatValue
                        );
                        
                        const startX = Math.min(this.selectionStart.x, x);
                        const startY = Math.min(this.selectionStart.y, y);
                        const width = Math.abs(x - this.selectionStart.x);
                        const height = Math.abs(y - this.selectionStart.y);
                        
                        this.ctx.strokeStyle = '#1a73e8';
                        this.ctx.fillStyle = 'rgba(26, 115, 232, 0.1)';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(startX, startY, width, height);
                        this.ctx.fillRect(startX, startY, width, height);
                    }
                } else if (!this.isDragging && !this.isSelecting && this.originalImage) {
                    // Crosshair
                    if (x < 70 || x > 70 + chartWidth || y < 50 || y > 50 + chartHeight) {
                        this.crosshair.style.display = 'none';
                        this.ctx.putImageData(this.originalImage, 0, 0);
                        return;
                    }
                    
                    this.ctx.putImageData(this.originalImage, 0, 0);
                    
                    this.ctx.strokeStyle = 'rgba(26, 115, 232, 0.8)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 50);
                    this.ctx.lineTo(x, 50 + chartHeight);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    this.updateCrosshair(x, e.clientX, e.clientY, chartWidth);
                }
            }
            
            handleMouseUp(e) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.classList.remove('dragging');
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    }
                    if (this.currentData) {
                        this.drawChart(
                            this.currentData.routes,
                            this.currentData.metricType,
                            this.currentData.yAxisLabel,
                            this.currentData.formatValue
                        );
                    }
                } else if (this.isSelecting && this.selectionStart) {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const chartWidth = this.canvas.width - 140;
                    
                    const startX = Math.min(this.selectionStart.x, x);
                    const endX = Math.max(this.selectionStart.x, x);
                    
                    if (Math.abs(endX - startX) > 20) {
                        const maxDistance = Math.max(...this.currentData.routes.map(r => {
                            const offset = this.routeOffsets[r.filename] || 0;
                            return r.stats.distance + offset;
                        }));
                        
                        const minDistance = ((startX - 70) / chartWidth) * maxDistance;
                        const maxDistanceZoom = ((endX - 70) / chartWidth) * maxDistance;
                        
                        this.zoomState = {
                            minDistance: Math.max(0, minDistance),
                            maxDistance: Math.min(maxDistance, maxDistanceZoom)
                        };
                        
                        document.getElementById('resetZoomBtn').disabled = false;
                        
                        if (this.currentData) {
                            this.drawChart(
                                this.currentData.routes,
                                this.currentData.metricType,
                                this.currentData.yAxisLabel,
                                this.currentData.formatValue
                            );
                        }
                    }
                }
                
                this.isSelecting = false;
                this.selectionStart = null;
            }
            
            handleMouseLeave() {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.classList.remove('dragging');
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    }
                }
                this.isSelecting = false;
                this.selectionStart = null;
                this.crosshair.style.display = 'none';
            }
            
            handleMouseEnter() {
                if (this.currentData) {
                    this.originalImage = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                }
            }
            
            updateCrosshair(x, clientX, clientY, chartWidth) {
                if (!this.currentData) return;
                
                const maxDist = this.zoomState ? 
                    (this.zoomState.maxDistance - this.zoomState.minDistance) :
                    Math.max(...this.currentData.routes.map(r => {
                        const offset = this.routeOffsets[r.filename] || 0;
                        return r.stats.distance + offset;
                    }));
                
                const mouseDistance = ((x - 70) / chartWidth) * maxDist;
                
                let tooltipHTML = `<div class="crosshair-distance">🗺️ ${Utils.formatDistance(mouseDistance)}</div>`;
                let foundData = false;
                
                this.currentData.processedRoutes.forEach(route => {
                    let closestIdx = -1;
                    let closestDiff = Infinity;
                    
                    for (let i = 0; i < route.cumulativeDistances.length; i++) {
                        const diff = Math.abs(route.cumulativeDistances[i] - mouseDistance);
                        if (diff < closestDiff) {
                            closestDiff = diff;
                            closestIdx = i;
                        }
                    }
                    
                    if (closestIdx >= 0 && closestIdx < route.metricData.length) {
                        const value = route.metricData[closestIdx];
                        if (value !== null && value !== undefined) {
                            foundData = true;
                            tooltipHTML += `
                                <div class="crosshair-route">
                                    <div class="crosshair-color" style="background: ${route.color}"></div>
                                    <span>${route.displayName}:</span>
                                    <span class="crosshair-value">${this.currentData.formatValue(value)}</span>
                                </div>
                            `;
                        }
                    }
                });
                
                if (foundData) {
                    this.crosshair.innerHTML = tooltipHTML;
                    this.crosshair.style.display = 'block';
                    this.crosshair.style.left = (clientX + 15) + 'px';
                    this.crosshair.style.top = (clientY + 15) + 'px';
                    
                    setTimeout(() => {
                        const rect = this.crosshair.getBoundingClientRect();
                        if (rect.right > window.innerWidth) {
                            this.crosshair.style.left = (clientX - rect.width - 15) + 'px';
                        }
                        if (rect.bottom > window.innerHeight) {
                            this.crosshair.style.top = (clientY - rect.height - 15) + 'px';
                        }
                    }, 0);
                } else {
                    this.crosshair.style.display = 'none';
                }
            }
            
            drawChart(routes, metricType, yAxisLabel, formatValue) {
                this.currentData = { routes, metricType, yAxisLabel, formatValue, processedRoutes: [] };
                
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                
                const padding = { left: 70, right: 70, top: 50, bottom: 70 };
                const chartWidth = this.canvas.width - padding.left - padding.right;
                const chartHeight = this.canvas.height - padding.top - padding.bottom;
                
                // Process route data
                const processedRoutes = routes.map(route => {
                    const distances = [0];
                    for (let i = 1; i < route.coordinates.length; i++) {
                        distances.push(distances[i-1] + Utils.haversineDistance(route.coordinates[i-1], route.coordinates[i]));
                    }
                    
                    let metricData = [];
                    switch(metricType) {
                        case 'elevation': metricData = route.elevations; break;
                        case 'speed': metricData = route.speeds; break;
                        case 'pace': metricData = route.paces; break;
                        case 'heartrate': metricData = route.heartRates; break;
                        case 'cadence': metricData = route.cadences; break;
                        case 'power': metricData = route.powers; break;
                    }
                    
                    const totalDist = distances[distances.length - 1];
                    const { windowSize, decimationFactor } = Utils.getAdaptiveSmoothingParams(totalDist);
                    const smoothed = Utils.smoothData(metricData, windowSize);
                    const { data: finalData, distances: finalDistances } = Utils.decimateData(smoothed, distances, decimationFactor);
                    
                    const offset = this.routeOffsets[route.filename] || 0;
                    return {
                        ...route,
                        cumulativeDistances: finalDistances.map(d => d + offset),
                        metricData: finalData,
                        totalDistance: totalDist
                    };
                });
                
                this.currentData.processedRoutes = processedRoutes;
                
                // Apply zoom if active
                let chartRoutes = processedRoutes;
                if (this.zoomState) {
                    chartRoutes = processedRoutes.map(route => ({
                        ...route,
                        metricData: route.metricData.filter((_, i) => {
                            const dist = route.cumulativeDistances[i];
                            return dist >= this.zoomState.minDistance && dist <= this.zoomState.maxDistance;
                        }),
                        cumulativeDistances: route.cumulativeDistances
                            .filter(d => d >= this.zoomState.minDistance && d <= this.zoomState.maxDistance)
                            .map(d => d - this.zoomState.minDistance)
                    }));
                }
                
                // Calculate ranges
                let globalMin = Infinity, globalMax = -Infinity, maxDistance = 0;
                chartRoutes.forEach(route => {
                    if (route.metricData.length > 0) {
                        globalMin = Math.min(globalMin, ...route.metricData);
                        globalMax = Math.max(globalMax, ...route.metricData);
                    }
                    maxDistance = Math.max(maxDistance, ...route.cumulativeDistances);
                });
                
                const range = globalMax - globalMin;
                globalMin -= range * 0.1;
                globalMax += range * 0.1;
                const adjustedRange = globalMax - globalMin;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = padding.top + (chartHeight / 5) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding.left, y);
                    this.ctx.lineTo(padding.left + chartWidth, y);
                    this.ctx.stroke();
                    
                    const value = globalMax - (adjustedRange / 5) * i;
                    this.ctx.fillStyle = '#666';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(formatValue(value).split(' ')[0], padding.left - 8, y + 4);
                }
                
                for (let i = 0; i <= 10; i++) {
                    const x = padding.left + (chartWidth / 10) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, padding.top);
                    this.ctx.lineTo(x, padding.top + chartHeight);
                    this.ctx.stroke();
                    
                    const dist = (maxDistance / 10) * i;
                    this.ctx.fillStyle = '#666';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(Utils.formatDistance(dist), x, this.canvas.height - padding.bottom + 20);
                }
                
                // Draw routes
                chartRoutes.forEach(route => {
                    if (routes.length === 1) {
                        // Fill area for single route
                        this.ctx.strokeStyle = route.color;
                        this.ctx.fillStyle = route.color + '25';
                        this.ctx.lineWidth = 1.5;
                        this.ctx.beginPath();
                        this.ctx.moveTo(padding.left, this.canvas.height - padding.bottom);
                        
                        for (let i = 0; i < route.metricData.length; i++) {
                            if (route.metricData[i] !== null) {
                                const x = padding.left + (route.cumulativeDistances[i] / maxDistance) * chartWidth;
                                const y = padding.top + chartHeight - ((route.metricData[i] - globalMin) / adjustedRange) * chartHeight;
                                this.ctx.lineTo(x, y);
                            }
                        }
                        
                        const lastX = padding.left + (route.cumulativeDistances[route.cumulativeDistances.length - 1] / maxDistance) * chartWidth;
                        this.ctx.lineTo(lastX, this.canvas.height - padding.bottom);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                    
                    // Draw line
                    this.ctx.strokeStyle = route.color;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.beginPath();
                    
                    let firstPoint = true;
                    for (let i = 0; i < route.metricData.length; i++) {
                        if (route.metricData[i] !== null) {
                            const x = padding.left + (route.cumulativeDistances[i] / maxDistance) * chartWidth;
                            const y = padding.top + chartHeight - ((route.metricData[i] - globalMin) / adjustedRange) * chartHeight;
                            if (firstPoint) {
                                this.ctx.moveTo(x, y);
                                firstPoint = false;
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                    }
                    this.ctx.stroke();
                    this.ctx.globalAlpha = 1.0;
                });
                
                // Draw axes
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding.left, padding.top);
                this.ctx.lineTo(padding.left, padding.top + chartHeight);
                this.ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
                this.ctx.stroke();
                
                // Labels
                this.ctx.save();
                this.ctx.translate(20, this.canvas.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillStyle = '#666';
                this.ctx.font = '14px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(yAxisLabel, 0, 0);
                this.ctx.restore();
                
                this.ctx.fillStyle = '#333';
                this.ctx.font = '14px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Distance', this.canvas.width / 2, this.canvas.height - 10);
                
                this.updateLegend();
                this.originalImage = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            }
            
            updateLegend() {
                if (!this.currentData) return;
                
                const legend = document.getElementById('chartLegend');
                legend.innerHTML = '';
                
                this.currentData.routes.forEach((route, index) => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    if (this.selectedRouteForDrag === index) item.classList.add('active');
                    
                    const color = document.createElement('div');
                    color.className = 'legend-color';
                    color.style.background = route.color;
                    
                    const label = document.createElement('span');
                    label.className = 'legend-label';
                    label.textContent = `${route.displayName} (${Utils.formatDistance(route.stats.distance)})`;
                    
                    const offset = this.routeOffsets[route.filename] || 0;
                    if (Math.abs(offset) > 0.01) {
                        const offsetSpan = document.createElement('span');
                        offsetSpan.className = 'legend-offset';
                        offsetSpan.textContent = offset >= 0 ? `+${Utils.formatDistance(offset)}` : Utils.formatDistance(offset);
                        label.appendChild(offsetSpan);
                    }
                    
                    item.appendChild(color);
                    item.appendChild(label);
                    
                    if (this.dragMode) {
                        item.style.cursor = 'pointer';
                        item.onclick = () => {
                            this.selectedRouteForDrag = this.selectedRouteForDrag === index ? null : index;
                            this.updateLegend();
                        };
                    }
                    
                    legend.appendChild(item);
                });
            }
        }

        // ============================================================================
        // FILE PARSER - Handles GPX and FIT file parsing
        // ============================================================================
        
        class FileParser {
            static parseGPX(xmlString, color, filename) {
                const parser = new DOMParser();
                const xml = parser.parseFromString(xmlString, 'text/xml');
                
                if (xml.getElementsByTagName('parsererror').length > 0) {
                    throw new Error('Invalid XML');
                }
                
                const coordinates = [], elevations = [], timestamps = [];
                const heartRates = [], cadences = [], powers = [];
                
                const trkpts = xml.getElementsByTagName('trkpt');
                const points = trkpts.length > 0 ? trkpts : xml.getElementsByTagName('rtept');
                
                for (let i = 0; i < points.length; i++) {
                    const lat = parseFloat(points[i].getAttribute('lat'));
                    const lon = parseFloat(points[i].getAttribute('lon'));
                    coordinates.push({ lat, lng: lon });
                    
                    const eleNode = points[i].getElementsByTagName('ele')[0];
                    elevations.push(eleNode ? parseFloat(eleNode.textContent) : null);
                    
                    const timeNode = points[i].getElementsByTagName('time')[0];
                    timestamps.push(timeNode ? new Date(timeNode.textContent) : null);
                    
                    const extensions = points[i].getElementsByTagName('extensions')[0];
                    heartRates.push(this.extractExtensionValue(extensions, ['tpx1:hr', 'gpxtpx:hr', 'ns3:hr', 'hr', 'heartrate', 'HeartRate']));
                    const cadenceValue = this.extractExtensionValue(extensions, ['tpx1:cad', 'gpxtpx:cad', 'ns3:cad', 'cad', 'cadence', 'Cadence', 'RunCadence']);
                    cadences.push(cadenceValue !== null && cadenceValue !== undefined ? cadenceValue * 2 : null);
                    powers.push(this.extractExtensionValue(extensions, ['tpx1:power', 'power', 'Power', 'gpxtpx:power', 'ns3:power', 'pwr']));
                }
                
                if (coordinates.length === 0) {
                    throw new Error('No track points found');
                }
                
                // Calculate speeds and paces
                const speeds = [], paces = [];
                for (let i = 0; i < coordinates.length; i++) {
                    if (i === 0 || !timestamps[i] || !timestamps[i-1]) {
                        speeds.push(null);
                        paces.push(null);
                    } else {
                        const dist = Utils.haversineDistance(coordinates[i-1], coordinates[i]);
                        const timeDiff = (timestamps[i] - timestamps[i-1]) / 1000 / 3600;
                        if (timeDiff > 0 && dist > 0) {
                            const speed = dist / timeDiff;
                            speeds.push(speed);
                            paces.push(60 / speed);
                        } else {
                            speeds.push(null);
                            paces.push(null);
                        }
                    }
                }
                
                return this.createRouteData(filename, color, coordinates, elevations, timestamps, 
                    heartRates, cadences, powers, speeds, paces);
            }
            
            static extractExtensionValue(extensions, tagNames) {
                if (!extensions) return null;
                for (let tagName of tagNames) {
                    const node = extensions.getElementsByTagName(tagName)[0];
                    if (node && node.textContent) {
                        const value = parseFloat(node.textContent);
                        if (!isNaN(value)) return value;
                    }
                }
                return null;
            }
            
            static parseFIT(arrayBuffer, color, filename) {
                return new Promise((resolve, reject) => {
                    if (!window.FitParser) {
                        reject(new Error('FIT parser not loaded'));
                        return;
                    }
                    
                    const fitParser = new FitParser({
                        force: true,
                        speedUnit: 'km/h',
                        lengthUnit: 'm',
                        temperatureUnit: 'celsius',
                        elapsedRecordField: true,
                        mode: 'list'
                    });
                    
                    fitParser.parse(arrayBuffer, (error, data) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        
                        const records = data.records || [];
                        if (records.length === 0) {
                            reject(new Error('No data points found'));
                            return;
                        }
                        
                        const coordinates = [], elevations = [], timestamps = [];
                        const heartRates = [], cadences = [], powers = [], speeds = [], paces = [];
                        
                        records.forEach(record => {
                            if (record.position_lat !== undefined && record.position_long !== undefined) {
                                const lat = record.position_lat;
                                const lng = record.position_long;
                                
                                if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
                                    coordinates.push({ lat, lng });
                                    elevations.push(record.enhanced_altitude ?? record.altitude ?? null);
                                    timestamps.push(record.timestamp ? new Date(record.timestamp) : null);
                                    heartRates.push(record.heart_rate ?? null);
                                    cadences.push(record.cadence !== null && record.cadence !== undefined ? record.cadence * 2 : null);
                                    powers.push(record.power ?? null);
                                    
                                    let speedKmh = null;
                                    // FIT parser already returns speed in km/h, no conversion needed
                                    if (record.enhanced_speed !== undefined && record.enhanced_speed !== null) {
                                        speedKmh = record.enhanced_speed;  // Already in km/h!
                                    } else if (record.speed !== undefined && record.speed !== null) {
                                        speedKmh = record.speed;  // Already in km/h!
                                    }
                                    speeds.push(speedKmh);
                                    paces.push(speedKmh && speedKmh > 0 ? 60 / speedKmh : null);
                                }
                            }
                        });
                        
                        if (coordinates.length === 0) {
                            reject(new Error('No valid GPS data found'));
                            return;
                        }
                        
                        // DEBUG: Log FIT parsing summary
                        const nonNullSpeeds = speeds.filter(s => s !== null && s !== undefined);
                        console.log('✅ FIT File Parsed:');
                        console.log(`  Total points: ${coordinates.length}`);
                        console.log(`  Speed values: ${nonNullSpeeds.length} non-null of ${speeds.length} total`);
                        if (nonNullSpeeds.length > 0) {
                            const sortedSpeeds = [...nonNullSpeeds].sort((a, b) => a - b);
                            console.log(`  Speed range: ${sortedSpeeds[0].toFixed(1)} - ${sortedSpeeds[sortedSpeeds.length-1].toFixed(1)} km/h`);
                            console.log(`  Median speed: ${sortedSpeeds[Math.floor(sortedSpeeds.length/2)].toFixed(1)} km/h`);
                        }
                        
                        resolve(this.createRouteData(filename, color, coordinates, elevations, 
                            timestamps, heartRates, cadences, powers, speeds, paces));
                    });
                });
            }
            
            static createRouteData(filename, color, coordinates, elevations, timestamps, 
                heartRates, cadences, powers, speeds, paces) {
                const distance = Utils.calculateDistance(coordinates);
                const elevStats = Utils.calculateElevationStats(elevations); // Don't filter here, function will handle it
                
                let duration = null;
                const validTimestamps = timestamps.filter(t => t !== null);
                if (validTimestamps.length >= 2) {
                    duration = (validTimestamps[validTimestamps.length - 1] - validTimestamps[0]) / 1000; // Store in SECONDS
                }
                
                // DEBUG: Verify speeds array
                const nonNullSpeeds = speeds.filter(s => s !== null && s !== undefined);
                console.log('📦 Creating Route Data:');
                console.log(`  Coordinates: ${coordinates.length}`);
                console.log(`  Speeds: ${speeds.length} (${nonNullSpeeds.length} non-null)`);
                console.log(`  Timestamps: ${timestamps.length}`);
                if (nonNullSpeeds.length > 0) {
                    const sorted = [...nonNullSpeeds].sort((a, b) => a - b);
                    console.log(`  Speed median from stored data: ${sorted[Math.floor(sorted.length/2)].toFixed(1)} km/h`);
                }
                
                return {
                    filename,
                    color,
                    coordinates,
                    elevations,
                    heartRates,
                    cadences,
                    powers,
                    speeds,  // DON'T filter - keep same length as coordinates
                    paces,   // DON'T filter - keep same length as coordinates
                    timestamps,
                    stats: {
                        distance,
                        elevationGain: elevStats.gain,
                        elevationLoss: elevStats.loss,
                        minElevation: elevStats.min,
                        maxElevation: elevStats.max,
                        duration
                    }
                };
            }
        }

        // ============================================================================
        // APPLICATION CLASS - Main application controller
        // ============================================================================
        
        class RouteOverlayApp {
            constructor() {
                this.routes = [];
                this.rawFiles = []; // Track original uploaded files
                this.mapManager = null;
                this.animationManager = null;
                this.chartManager = null;
                this.compareMode = false;
                this.highlightedRoute = null;
                this.highlightTimeout = null;
                
                // Firebase integration
                this.currentUser = null;
                this.savedSessions = [];
                
                this.initializeWhenReady();
            }
            
            initializeWhenReady() {
                if (typeof google !== 'undefined' && google.maps) {
                    this.initialize();
                } else {
                    window.initMap = () => this.initialize();
                }
            }
            
            initialize() {
                this.mapManager = new MapManager(document.getElementById('map'));
                this.animationManager = new AnimationManager(this.mapManager);
                this.chartManager = new ChartManager();
                
                this.setupEventListeners();
                this.setupDragAndDrop();
                this.setupFirebaseAuth();
            }
            
            setupFirebaseAuth() {
                // Auth button listeners
                const authButton = document.getElementById('authButton');
                const signOutBtn = document.getElementById('signOutBtn');
                
                authButton.addEventListener('click', async () => {
                    const user = await authManager.signInWithGoogle();
                    if (user) {
                        this.onUserSignedIn(user);
                    }
                });
                
                signOutBtn.addEventListener('click', async () => {
                    await authManager.signOut();
                    this.onUserSignedOut();
                });
                
                // Save current routes button
                document.getElementById('saveCurrentBtn').addEventListener('click', () => {
                    this.saveCurrentRoutes();
                });
                
                // Listen for auth state changes
                authManager.onAuthStateChanged((user) => {
                    if (user) {
                        this.onUserSignedIn(user);
                    } else {
                        this.onUserSignedOut();
                    }
                });
            }
            
            onUserSignedIn(user) {
                this.currentUser = user;
                storageManager.setUser(user.uid);
                
                // Update UI
                document.getElementById('authButton').style.display = 'none';
                document.getElementById('userInfo').classList.add('visible');
                document.getElementById('userName').textContent = user.displayName;
                document.getElementById('userAvatar').src = user.photoURL;
                document.getElementById('savedRoutesSection').classList.add('visible');
                
                // Show save button if routes exist
                if (this.routes.length > 0) {
                    document.getElementById('saveCurrentBtn').classList.add('visible');
                }
                
                // Load saved sessions
                this.loadSavedSessions();
                
                console.log('👤 User signed in:', user.displayName);
            }
            
            onUserSignedOut() {
                this.currentUser = null;
                this.savedSessions = [];
                
                // Update UI
                document.getElementById('authButton').style.display = 'flex';
                document.getElementById('userInfo').classList.remove('visible');
                document.getElementById('savedRoutesSection').classList.remove('visible');
                document.getElementById('saveCurrentBtn').classList.remove('visible');
                document.getElementById('savedRoutesList').innerHTML = '';
                
                console.log('👤 User signed out');
            }
            
            async saveCurrentRoutes() {
                if (this.routes.length === 0) {
                    alert('No routes to save! Please upload some GPX or FIT files first.');
                    return;
                }
                
                if (this.rawFiles.length !== this.routes.length) {
                    alert('Error: Mismatch between routes and files. Please reload the page and try again.');
                    return;
                }
                
                const saveBtn = document.getElementById('saveCurrentBtn');
                const originalText = saveBtn.innerHTML;
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<span class="loading-spinner"></span> Uploading...';
                
                const sessionId = await storageManager.saveRoutes(this.routes, this.rawFiles);
                
                if (sessionId) {
                    saveBtn.innerHTML = '✅ Saved!';
                    setTimeout(() => {
                        saveBtn.innerHTML = originalText;
                        saveBtn.disabled = false;
                    }, 2000);
                    
                    // Refresh saved sessions list
                    this.loadSavedSessions();
                } else {
                    saveBtn.innerHTML = originalText;
                    saveBtn.disabled = false;
                }
            }
            
            async loadSavedSessions() {
                const sessions = await storageManager.getSavedSessions();
                this.savedSessions = sessions;
                this.renderSavedSessions();
            }
            
            renderSavedSessions() {
                const listEl = document.getElementById('savedRoutesList');
                
                if (this.savedSessions.length === 0) {
                    listEl.innerHTML = '<p style="color: #5f6368; font-size: 12px; text-align: center;">No saved sessions yet</p>';
                    return;
                }
                
                listEl.innerHTML = this.savedSessions.map(session => {
                    const date = session.createdAt ? new Date(session.createdAt.toDate()).toLocaleDateString() : 'Unknown date';
                    const routeCount = session.routeCount || 0;
                    const totalSize = session.totalSize ? (session.totalSize / 1024 / 1024).toFixed(1) : '0';
                    const firstRouteName = session.files && session.files.length > 0 ? session.files[0].displayName : 'Unnamed';
                    
                    return `
                        <div class="saved-route-item">
                            <div class="saved-route-info">
                                <div class="saved-route-name">${firstRouteName}${routeCount > 1 ? ` +${routeCount - 1} more` : ''}</div>
                                <div class="saved-route-meta">${date} • ${routeCount} file${routeCount !== 1 ? 's' : ''} • ${totalSize} MB</div>
                            </div>
                            <div class="saved-route-actions">
                                <button class="saved-route-btn" onclick="app.loadSavedSession('${session.id}')">Load</button>
                                <button class="saved-route-btn delete" onclick="app.deleteSavedSession('${session.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            async loadSavedSession(sessionId) {
                const session = await storageManager.loadSession(sessionId);
                if (!session || !session.routes) {
                    alert('Failed to load session');
                    return;
                }
                
                // Clear current routes and raw files
                this.routes.forEach(route => route.removeFromMap());
                this.routes = [];
                this.rawFiles = []; // Clear raw files when loading from cloud
                
                // Load saved routes
                for (const routeData of session.routes) {
                    this.addRoute(routeData);
                }
                
                console.log(`✅ Loaded ${session.routes.length} routes from saved session`);
                
                // Note: Loaded routes cannot be re-saved as they don't have original files
                // Show info to user
                const saveBtn = document.getElementById('saveCurrentBtn');
                if (saveBtn.classList.contains('visible')) {
                    saveBtn.disabled = true;
                    saveBtn.title = 'Cannot re-save loaded sessions. Upload new files to save.';
                }
            }
            
            async deleteSavedSession(sessionId) {
                if (!confirm('Are you sure you want to delete this saved session?')) {
                    return;
                }
                
                const success = await storageManager.deleteSession(sessionId);
                if (success) {
                    this.loadSavedSessions();
                }
            }
            
            setupEventListeners() {
                // File inputs
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
                document.getElementById('compactFileInput').addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Compare mode
                document.getElementById('compareBtn').addEventListener('click', () => this.toggleCompareMode());
                
                // Sidebar toggle
                document.getElementById('sidebarToggle').addEventListener('click', () => this.toggleSidebar());
                
                // Insights modal close button
                document.getElementById('closeInsightsModal').addEventListener('click', () => this.closeInsightsModal());
                
                // Comparison panel - use event delegation
                document.querySelector('.comparison-actions').addEventListener('click', (e) => {
                    if (e.target.classList.contains('comparison-elevation-btn')) {
                        this.compareMetric(e.target.dataset.metric);
                    } else if (e.target.classList.contains('comparison-close')) {
                        this.closeComparison();
                    }
                });
                
                // File list - use event delegation
                const fileList = document.getElementById('fileList');
                fileList.addEventListener('click', (e) => this.handleFileListClick(e));
                fileList.addEventListener('change', (e) => this.handleFileListChange(e));
                fileList.addEventListener('blur', (e) => this.handleFileListBlur(e), true);
            }
            
            setupDragAndDrop() {
                const setupDropZone = (zone, input) => {
                    zone.addEventListener('click', () => input.click());
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        zone.classList.add('dragover');
                    });
                    zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.classList.remove('dragover');
                        this.handleFiles(e.dataTransfer.files);
                    });
                };
                
                setupDropZone(document.getElementById('dropZone'), document.getElementById('fileInput'));
                setupDropZone(document.getElementById('compactDropZone'), document.getElementById('compactFileInput'));
            }
            
            handleFileListClick(e) {
                const fileItem = e.target.closest('.file-item');
                if (!fileItem) return;
                
                const index = Array.from(fileItem.parentElement.children).indexOf(fileItem);
                
                // Handle specific button clicks
                if (e.target.classList.contains('file-play')) {
                    this.toggleAnimation(index);
                } else if (e.target.classList.contains('file-toggle')) {
                    this.toggleVisibility(index);
                } else if (e.target.classList.contains('file-remove')) {
                    this.removeRoute(index);
                } else if (e.target.classList.contains('compare-checkbox')) {
                    this.toggleSelection(index);
                } else if (!e.target.classList.contains('file-display-name')) {
                    // Click on item itself
                    if (!this.compareMode) {
                        this.highlightRoute(index);
                    }
                }
            }
            
            handleFileListChange(e) {
                if (e.target.classList.contains('compare-checkbox')) {
                    const fileItem = e.target.closest('.file-item');
                    const index = Array.from(fileItem.parentElement.children).indexOf(fileItem);
                    this.toggleSelection(index);
                }
            }
            
            handleFileListBlur(e) {
                if (e.target.classList.contains('file-display-name')) {
                    const fileItem = e.target.closest('.file-item');
                    const index = Array.from(fileItem.parentElement.children).indexOf(fileItem);
                    const route = this.routes[index];
                    route.displayName = e.target.textContent.trim() || route.displayName;
                    e.target.textContent = route.displayName;
                }
            }
            
            handleFileSelect(e) {
                this.handleFiles(e.target.files);
                e.target.value = '';
            }
            
            async handleFiles(files) {
                const fileArray = Array.from(files);
                
                for (const file of fileArray) {
                    const isGPX = file.name.toLowerCase().endsWith('.gpx');
                    const isFIT = file.name.toLowerCase().endsWith('.fit');
                    
                    if (!isGPX && !isFIT) {
                        alert(`${file.name} is not a GPX or FIT file`);
                        continue;
                    }
                    
                    try {
                        const color = Utils.colors[this.routes.length % Utils.colors.length];
                        
                        // Store the raw file for later saving
                        this.rawFiles.push(file);
                        
                        if (isGPX) {
                            const text = await file.text();
                            const routeData = FileParser.parseGPX(text, color, file.name);
                            this.addRoute(routeData);
                        } else {
                            const buffer = await file.arrayBuffer();
                            const routeData = await FileParser.parseFIT(buffer, color, file.name);
                            this.addRoute(routeData);
                        }
                    } catch (error) {
                        alert(`Error parsing ${file.name}: ${error.message}`);
                    }
                }
            }
            
            addRoute(routeData) {
                const route = new Route(routeData);
                const index = this.routes.length;
                
                route.createMapObjects(this.mapManager.map, index, {
                    onMouseOver: (r, e) => {
                        const pointInfo = r.getClosestPointInfo(e.latLng);
                        this.mapManager.showTooltip(r.displayName, e.latLng, pointInfo.distance, pointInfo.time);
                    },
                    onMouseMove: (r, e) => {
                        const pointInfo = r.getClosestPointInfo(e.latLng);
                        this.mapManager.showTooltip(r.displayName, e.latLng, pointInfo.distance, pointInfo.time);
                    },
                    onMouseOut: () => this.mapManager.hideTooltip(),
                    onClick: (r) => this.highlightRoute(this.routes.indexOf(r))
                });
                
                this.routes.push(route);
                this.updateUI();
                this.mapManager.fitToRoutes(this.routes);
            }
            
            removeRoute(index) {
                const route = this.routes[index];
                
                if (route.isPlaying) {
                    this.animationManager.stop(route);
                }
                
                route.destroy();
                this.routes.splice(index, 1);
                
                // Also remove corresponding raw file if it exists
                if (this.rawFiles[index]) {
                    this.rawFiles.splice(index, 1);
                }
                
                this.updateUI();
                
                if (this.compareMode) {
                    this.updateComparison();
                }
                
                if (this.routes.length === 0) {
                    this.closeComparison();
                    this.mapManager.map.setCenter({ lat: 40, lng: -100 });
                    this.mapManager.map.setZoom(4);
                } else {
                    this.mapManager.fitToRoutes(this.routes);
                }
            }
            
            toggleVisibility(index) {
                const route = this.routes[index];
                route.setVisible(!route.visible, this.mapManager.map);
                this.updateUI();
            }
            
            toggleAnimation(index) {
                const route = this.routes[index];
                
                if (route.isPlaying) {
                    this.animationManager.stop(route);
                } else {
                    this.animationManager.start(route);
                }
                
                this.updateUI();
            }
            
            highlightRoute(index) {
                if (this.highlightedRoute !== null) {
                    this.routes[this.highlightedRoute].highlight(false);
                    document.querySelectorAll('.file-item')[this.highlightedRoute]?.classList.remove('highlighted');
                    clearTimeout(this.highlightTimeout);
                }
                
                if (index !== null && this.routes[index]) {
                    this.routes[index].highlight(true);
                    const fileItems = document.querySelectorAll('.file-item');
                    if (fileItems[index]) {
                        fileItems[index].classList.add('highlighted');
                        fileItems[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                    
                    this.highlightedRoute = index;
                    
                    this.highlightTimeout = setTimeout(() => {
                        if (this.highlightedRoute === index) {
                            this.routes[index].highlight(false);
                            fileItems[index]?.classList.remove('highlighted');
                            this.highlightedRoute = null;
                        }
                    }, 2000);
                }
            }
            
            toggleCompareMode() {
                this.compareMode = !this.compareMode;
                const btn = document.getElementById('compareBtn');
                const fileList = document.getElementById('fileList');
                
                if (this.compareMode) {
                    btn.classList.add('active');
                    btn.textContent = '✓ Compare Mode';
                    fileList.classList.add('compare-mode');
                } else {
                    btn.classList.remove('active');
                    btn.textContent = '📊 Compare Routes';
                    fileList.classList.remove('compare-mode');
                    this.routes.forEach(r => r.selected = false);
                    this.closeComparison();
                }
                
                this.updateUI();
            }
            
            toggleSelection(index) {
                if (!this.compareMode) return;
                this.routes[index].selected = !this.routes[index].selected;
                this.updateUI();
                this.updateComparison();
            }
            
            showGraph(index) {
                const route = this.routes[index];
                const dropdown = document.getElementById(`metricDropdown${index}`);
                const metricType = dropdown.value;
                
                const metricConfig = {
                    elevation: { data: route.elevations, name: 'Elevation', label: 'Elevation (m)', format: v => Math.round(v) + 'm' },
                    speed: { data: route.speeds, name: 'Speed', label: 'Speed (km/h)', format: v => v.toFixed(1) + ' km/h' },
                    pace: { data: route.paces, name: 'Pace', label: 'Pace (min/km)', format: v => Utils.formatPace(v) },
                    heartrate: { data: route.heartRates, name: 'Heart Rate', label: 'Heart Rate (bpm)', format: v => Math.round(v) + ' bpm' },
                    cadence: { data: route.cadences, name: 'Cadence', label: 'Cadence (spm)', format: v => Math.round(v) + ' spm' },
                    power: { data: route.powers, name: 'Power', label: 'Power (W)', format: v => Math.round(v) + 'W' },
                    grade: { data: null, name: 'Grade', label: 'Grade (%)', format: v => v.toFixed(1) + '%' }
                };
                
                const config = metricConfig[metricType];
                if (!config) return;
                
                if (metricType === 'grade') {
                    if (!route.elevations || route.elevations.length === 0) {
                        alert('No elevation data available for grade calculation');
                        return;
                    }
                    this.showGradeChart([route]);
                } else {
                    if (!config.data || config.data.length === 0) {
                        alert(`No ${config.name.toLowerCase()} data available for this route`);
                        return;
                    }
                    this.chartManager.show([route], metricType, config.label, config.format);
                }
            }
            
            showGradeChart(routes) {
                const routesWithGrade = routes.map(route => {
                    const grades = [];
                    for (let i = 1; i < route.coordinates.length; i++) {
                        const dist = Utils.haversineDistance(route.coordinates[i-1], route.coordinates[i]) * 1000;
                        const elevChange = route.elevations[i] - route.elevations[i-1];
                        grades.push(dist > 0 ? (elevChange / dist) * 100 : 0);
                    }
                    return { ...route, elevations: grades };
                });
                
                this.chartManager.show(routesWithGrade, 'elevation', 'Grade (%)', v => v.toFixed(1) + '%');
            }
            
            showInsightsModal(route, index) {
                const modal = document.getElementById('insightsModal');
                const titleEl = document.getElementById('insightsModalTitle');
                titleEl.textContent = `Insights: ${route.displayName}`;
                
                // Show/hide tabs based on available data
                const tabsContainer = document.querySelector('.insights-tabs');
                const tabs = tabsContainer.querySelectorAll('.insights-tab');
                
                // Always show insights tab
                tabs[0].style.display = 'inline-block';
                tabs[0].setAttribute('data-metric', 'insights');
                
                // Show/hide other tabs based on data
                let tabIndex = 1;
                if (route.elevations.length > 0) {
                    tabs[tabIndex].style.display = 'inline-block';
                    tabs[tabIndex].setAttribute('data-metric', 'elevation');
                    tabIndex++;
                    tabs[tabIndex].style.display = 'inline-block';
                    tabs[tabIndex].setAttribute('data-metric', 'grade');
                    tabIndex++;
                }
                if (route.speeds.length > 0) {
                    tabs[tabIndex].style.display = 'inline-block';
                    tabs[tabIndex].setAttribute('data-metric', 'speed');
                    tabIndex++;
                }
                if (route.paces.length > 0) {
                    tabs[tabIndex].style.display = 'inline-block';
                    tabs[tabIndex].setAttribute('data-metric', 'pace');
                    tabIndex++;
                }
                if (route.heartRates.length > 0) {
                    tabs[tabIndex].style.display = 'inline-block';
                    tabs[tabIndex].setAttribute('data-metric', 'heartrate');
                    tabIndex++;
                }
                if (route.cadences.length > 0) {
                    tabs[tabIndex].style.display = 'inline-block';
                    tabs[tabIndex].setAttribute('data-metric', 'cadence');
                    tabIndex++;
                }
                if (route.powers.length > 0) {
                    tabs[tabIndex].style.display = 'inline-block';
                    tabs[tabIndex].setAttribute('data-metric', 'power');
                    tabIndex++;
                }
                
                // Hide unused tabs
                for (let i = tabIndex; i < tabs.length; i++) {
                    tabs[i].style.display = 'none';
                }
                
                // Generate insights
                const insightsContent = document.getElementById('insightsTabContent');
                insightsContent.innerHTML = '<div class="insights-grid">' + this.generateInsights(route).join('') + '</div>';
                
                // Reset to insights tab
                tabs.forEach(t => t.classList.remove('active'));
                tabs[0].classList.add('active');
                document.getElementById('insightsTabContent').classList.add('active');
                document.getElementById('graphTabContent').classList.remove('active');
                
                // Clear metric-specific insights (they'll populate when switching to graph tabs)
                const metricInsightsContainer = document.getElementById('metricSpecificInsights');
                if (metricInsightsContainer) {
                    metricInsightsContainer.innerHTML = '';
                }
                
                // Store route and index for later use
                this.currentInsightsRoute = route;
                this.currentInsightsIndex = index;
                
                // Remove old event listeners by cloning
                tabs.forEach((tab) => {
                    const newTab = tab.cloneNode(true);
                    tab.parentNode.replaceChild(newTab, tab);
                });
                
                // Setup tab click handlers on the new tabs
                const newTabs = tabsContainer.querySelectorAll('.insights-tab');
                newTabs.forEach((tab) => {
                    tab.addEventListener('click', () => {
                        const metricType = tab.getAttribute('data-metric');
                        
                        // Hide crosshair when switching tabs
                        const crosshair = document.getElementById('insightsCrosshair');
                        if (crosshair) {
                            crosshair.style.display = 'none';
                        }
                        
                        // Update active states
                        newTabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        if (metricType === 'insights') {
                            // Insights tab
                            document.getElementById('insightsTabContent').classList.add('active');
                            document.getElementById('graphTabContent').classList.remove('active');
                            
                            // Clear metric-specific insights
                            const metricInsightsContainer = document.getElementById('metricSpecificInsights');
                            if (metricInsightsContainer) {
                                metricInsightsContainer.innerHTML = '';
                            }
                        } else {
                            // Graph tab
                            document.getElementById('insightsTabContent').classList.remove('active');
                            document.getElementById('graphTabContent').classList.add('active');
                            
                            this.renderInsightGraph(route, metricType);
                        }
                    });
                });
                
                modal.classList.add('show');
            }
            
            
            renderInsightGraph(route, metricType) {
                const metricConfig = {
                    elevation: { data: route.elevations, name: 'Elevation', label: 'Elevation (m)', format: v => Math.round(v) + 'm' },
                    speed: { data: route.speeds, name: 'Speed', label: 'Speed (km/h)', format: v => v.toFixed(1) + ' km/h' },
                    pace: { data: route.paces, name: 'Pace', label: 'Pace (min/km)', format: v => Utils.formatPace(v) },
                    heartrate: { data: route.heartRates, name: 'Heart Rate', label: 'Heart Rate (bpm)', format: v => Math.round(v) + ' bpm' },
                    cadence: { data: route.cadences, name: 'Cadence', label: 'Cadence (spm)', format: v => Math.round(v) + ' spm' },
                    power: { data: route.powers, name: 'Power', label: 'Power (W)', format: v => Math.round(v) + 'W' },
                    grade: { data: null, name: 'Grade', label: 'Grade (%)', format: v => v.toFixed(1) + '%' }
                };
                
                const config = metricConfig[metricType];
                if (!config) return;
                
                // Get canvas and set proper dimensions
                const canvas = document.getElementById('insightsChart');
                const container = canvas.parentElement;
                canvas.width = container.clientWidth || 1000;
                canvas.height = 400;
                
                // Create dummy modal object with proper classList and querySelector
                const dummyModalClose = {
                    addEventListener: () => {}
                };
                const dummyModal = { 
                    classList: { 
                        add: () => {},
                        remove: () => {},
                        contains: () => false
                    },
                    querySelector: () => dummyModalClose
                };
                
                // Store current insightsChartManager or create new one
                if (!this.insightsChartManager) {
                    // We can't use the ChartManager constructor because it will try to access 
                    // elevationModal and elevationChart. So we manually create the instance.
                    this.insightsChartManager = Object.create(ChartManager.prototype);
                    
                    // Manually initialize the properties
                    this.insightsChartManager.canvas = canvas;
                    this.insightsChartManager.ctx = canvas.getContext('2d');
                    this.insightsChartManager.modal = dummyModal;
                    this.insightsChartManager.crosshair = document.getElementById('insightsCrosshair');
                    this.insightsChartManager.currentData = null;
                    this.insightsChartManager.zoomState = null;
                    this.insightsChartManager.dragMode = false;
                    this.insightsChartManager.selectedRouteForDrag = null;
                    this.insightsChartManager.routeOffsets = {};
                    this.insightsChartManager.isDragging = false;
                    this.insightsChartManager.isSelecting = false;
                    this.insightsChartManager.dragStartX = null;
                    this.insightsChartManager.dragStartOffset = 0;
                    this.insightsChartManager.selectionStart = null;
                    this.insightsChartManager.animationFrameId = null;
                    this.insightsChartManager.originalImage = null;
                    
                    // Override updateLegend to use insightsChartLegend
                    const originalUpdateLegend = this.insightsChartManager.updateLegend.bind(this.insightsChartManager);
                    this.insightsChartManager.updateLegend = function() {
                        if (!this.currentData) return;
                        
                        const legend = document.getElementById('insightsChartLegend');
                        if (!legend) return;
                        legend.innerHTML = '';
                        
                        this.currentData.routes.forEach((route, index) => {
                            const item = document.createElement('div');
                            item.className = 'legend-item';
                            if (this.selectedRouteForDrag === index) item.classList.add('active');
                            
                            const color = document.createElement('div');
                            color.className = 'legend-color';
                            color.style.background = route.color;
                            
                            const label = document.createElement('span');
                            label.className = 'legend-label';
                            label.textContent = `${route.displayName} (${Utils.formatDistance(route.stats.distance)})`;
                            
                            const offset = this.routeOffsets[route.filename] || 0;
                            if (Math.abs(offset) > 0.01) {
                                const offsetSpan = document.createElement('span');
                                offsetSpan.className = 'legend-offset';
                                offsetSpan.textContent = offset >= 0 ? `+${Utils.formatDistance(offset)}` : Utils.formatDistance(offset);
                                label.appendChild(offsetSpan);
                            }
                            
                            item.appendChild(color);
                            item.appendChild(label);
                            
                            if (this.dragMode) {
                                item.style.cursor = 'pointer';
                                item.onclick = () => {
                                    this.selectedRouteForDrag = this.selectedRouteForDrag === index ? null : index;
                                    this.updateLegend();
                                };
                            }
                            
                            legend.appendChild(item);
                        });
                    };
                    
                    // Don't call setupEventListeners as it tries to access modal elements
                    // Instead manually set up canvas listeners
                    canvas.addEventListener('mousedown', (e) => this.insightsChartManager.handleMouseDown(e));
                    canvas.addEventListener('mousemove', (e) => this.insightsChartManager.handleMouseMove(e));
                    canvas.addEventListener('mouseup', (e) => this.insightsChartManager.handleMouseUp(e));
                    canvas.addEventListener('mouseleave', () => this.insightsChartManager.handleMouseLeave());
                    canvas.addEventListener('mouseenter', () => this.insightsChartManager.handleMouseEnter());
                    
                    // Disable drag mode for single route insights
                    this.insightsChartManager.dragMode = false;
                    
                    // Override handleMouseUp to use the insights modal's button IDs (no drag mode)
                    this.insightsChartManager.handleMouseUp = function(e) {
                        if (this.isSelecting && this.selectionStart) {
                            const rect = this.canvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const chartWidth = this.canvas.width - 140;
                            
                            const startX = Math.min(this.selectionStart.x, x);
                            const endX = Math.max(this.selectionStart.x, x);
                            
                            if (Math.abs(endX - startX) > 20) {
                                const maxDistance = Math.max(...this.currentData.routes.map(r => {
                                    const offset = this.routeOffsets[r.filename] || 0;
                                    return r.stats.distance + offset;
                                }));
                                
                                const minDistance = ((startX - 70) / chartWidth) * maxDistance;
                                const maxDistanceZoom = ((endX - 70) / chartWidth) * maxDistance;
                                
                                this.zoomState = {
                                    minDistance: Math.max(0, minDistance),
                                    maxDistance: Math.min(maxDistance, maxDistanceZoom)
                                };
                                
                                // Use insights modal button ID
                                document.getElementById('insightsResetZoomBtn').disabled = false;
                                
                                if (this.currentData) {
                                    this.drawChart(
                                        this.currentData.routes,
                                        this.currentData.metricType,
                                        this.currentData.yAxisLabel,
                                        this.currentData.formatValue
                                    );
                                }
                            }
                        }
                        
                        this.isSelecting = false;
                        this.selectionStart = null;
                    };
                    
                    // Override handleMouseLeave to ensure crosshair is hidden and canvas is clean
                    this.insightsChartManager.handleMouseLeave = function() {
                        this.isSelecting = false;
                        this.selectionStart = null;
                        if (this.crosshair) {
                            this.crosshair.style.display = 'none';
                        }
                        // Redraw to clear any crosshair artifacts
                        if (this.currentData) {
                            this.drawChart(
                                this.currentData.routes,
                                this.currentData.metricType,
                                this.currentData.yAxisLabel,
                                this.currentData.formatValue
                            );
                        }
                    };
                    
                    // Override handleMouseMove (no drag mode, only zoom selection and crosshair)
                    this.insightsChartManager.handleMouseMove = function(e) {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const chartWidth = this.canvas.width - 140;
                        const chartHeight = this.canvas.height - 120;
                        
                        if (this.isSelecting && this.selectionStart) {
                            if (this.currentData) {
                                this.drawChart(
                                    this.currentData.routes,
                                    this.currentData.metricType,
                                    this.currentData.yAxisLabel,
                                    this.currentData.formatValue
                                );
                                
                                const startX = Math.min(this.selectionStart.x, x);
                                const startY = Math.min(this.selectionStart.y, y);
                                const width = Math.abs(x - this.selectionStart.x);
                                const height = Math.abs(y - this.selectionStart.y);
                                
                                this.ctx.strokeStyle = '#1a73e8';
                                this.ctx.fillStyle = 'rgba(26, 115, 232, 0.1)';
                                this.ctx.lineWidth = 2;
                                this.ctx.strokeRect(startX, startY, width, height);
                                this.ctx.fillRect(startX, startY, width, height);
                            }
                        } else if (!this.isSelecting && this.originalImage) {
                            // Crosshair
                            if (x < 70 || x > 70 + chartWidth || y < 50 || y > 50 + chartHeight) {
                                if (this.crosshair) {
                                    this.crosshair.style.display = 'none';
                                }
                                this.ctx.putImageData(this.originalImage, 0, 0);
                                return;
                            }
                            
                            this.ctx.putImageData(this.originalImage, 0, 0);
                            
                            // Draw vertical crosshair line
                            this.ctx.strokeStyle = 'rgba(26, 115, 232, 0.8)';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, 50);
                            this.ctx.lineTo(x, 50 + chartHeight);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                            
                            this.updateCrosshair(x, e.clientX, e.clientY, chartWidth);
                        }
                    };
                }
                
                // Setup controls - only reset zoom button now
                const resetZoomBtn = document.getElementById('insightsResetZoomBtn');
                const newZoomBtn = resetZoomBtn.cloneNode(true);
                resetZoomBtn.parentNode.replaceChild(newZoomBtn, resetZoomBtn);
                
                newZoomBtn.onclick = () => {
                    this.insightsChartManager.zoomState = null;
                    newZoomBtn.disabled = true;
                    if (this.insightsChartManager.currentData) {
                        this.insightsChartManager.drawChart(
                            this.insightsChartManager.currentData.routes,
                            this.insightsChartManager.currentData.metricType,
                            this.insightsChartManager.currentData.yAxisLabel,
                            this.insightsChartManager.currentData.formatValue
                        );
                    }
                };
                
                // Render the appropriate chart
                if (metricType === 'grade') {
                    const grades = [];
                    for (let i = 1; i < route.coordinates.length; i++) {
                        const dist = Utils.haversineDistance(route.coordinates[i-1], route.coordinates[i]) * 1000;
                        const elevChange = route.elevations[i] - route.elevations[i-1];
                        grades.push(dist > 0 ? (elevChange / dist) * 100 : 0);
                    }
                    const routeWithGrade = { ...route, elevations: grades };
                    
                    // Call drawChart directly to avoid modal.classList.add('show')
                    this.insightsChartManager.drawChart([routeWithGrade], 'elevation', 'Grade (%)', v => v.toFixed(1) + '%');
                } else {
                    // Call drawChart directly to avoid modal.classList.add('show')
                    this.insightsChartManager.drawChart([route], metricType, config.label, config.format);
                }
                
                // Display metric-specific insights below the chart
                this.displayMetricInsights(route, metricType);
            }
            
            displayMetricInsights(route, metricType) {
                const container = document.getElementById('metricSpecificInsights');
                if (!container) return;
                
                let textContent = '';
                
                // Generate conversational text based on metric type
                switch(metricType) {
                    case 'heartrate':
                        textContent = this.generateHeartRateText(route);
                        break;
                    case 'speed':
                        textContent = this.generateSpeedText(route);
                        break;
                    case 'pace':
                        textContent = this.generatePaceText(route);
                        break;
                    case 'cadence':
                        textContent = this.generateCadenceText(route);
                        break;
                    case 'elevation':
                    case 'grade':
                        textContent = this.generateElevationText(route);
                        break;
                    case 'power':
                        textContent = '<p>Power analysis coming soon! We\'re working on bringing you detailed power metrics and insights.</p>';
                        break;
                    default:
                        textContent = '';
                }
                
                // Display text or show message if none available
                if (textContent) {
                    container.innerHTML = `<div class="metric-insights-text">${textContent}</div>`;
                } else {
                    container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No specific insights available for this metric</div>';
                }
            }
            
            generateHeartRateText(route) {
                if (route.heartRates.length < 10) return '';
                
                const validHR = route.heartRates.filter(hr => hr !== null && hr > 0);
                if (validHR.length === 0) return '';
                
                const avgHR = validHR.reduce((a, b) => a + b, 0) / validHR.length;
                const maxHR = Math.max(...validHR);
                const minHR = Math.min(...validHR);
                
                let text = '';
                
                // HR Drift
                const firstQuarter = validHR.slice(0, Math.floor(validHR.length / 4));
                const lastQuarter = validHR.slice(-Math.floor(validHR.length / 4));
                const firstAvg = firstQuarter.reduce((a, b) => a + b, 0) / firstQuarter.length;
                const lastAvg = lastQuarter.reduce((a, b) => a + b, 0) / lastQuarter.length;
                const drift = lastAvg - firstAvg;
                
                if (Math.abs(drift) > 5) {
                    const driftDesc = drift > 0 ? 'increased' : 'decreased';
                    text += `<p>💓 Your heart rate ${driftDesc} by <strong>${Math.abs(drift).toFixed(0)} bpm</strong> from the first quarter to the final stretch (${firstAvg.toFixed(0)} → ${lastAvg.toFixed(0)} bpm). `;
                    
                    if (drift > 15) {
                        text += `This is quite a significant drift. It could indicate dehydration, fatigue, or rising effort level in hot conditions. Consider your pacing strategy and hydration for future long efforts.`;
                    } else if (drift > 5) {
                        text += `This cardiac drift is pretty normal for longer efforts—your cardiovascular system works harder as fatigue sets in, even at the same pace.`;
                    } else {
                        text += `Negative drift like this is unusual and might indicate you started too conservatively or conditions got easier (cooler weather, downhill finish).`;
                    }
                    text += '</p>';
                }
                
                // Peak effort and range
                text += `<p>📈 Your heart hit a peak of <strong>${maxHR} bpm</strong> during the run`;
                const hrRange = maxHR - minHR;
                if (hrRange > 60) {
                    text += `, with quite a wide range of ${hrRange} bpm throughout. This suggests varied terrain or pacing, with some genuine hard efforts mixed with easier recovery sections`;
                } else if (hrRange > 40) {
                    text += `. With a range of ${hrRange} bpm, you experienced some variation but maintained relatively steady effort overall`;
                } else {
                    text += `. The narrow range of ${hrRange} bpm suggests very consistent effort—either steady pacing or similar terrain throughout`;
                }
                text += '.</p>';
                
                // Average context
                text += `<p><em>Your average heart rate was ${avgHR.toFixed(0)} bpm across the entire effort.</em></p>`;
                
                return text;
            }
            
            generateSpeedText(route) {
                if (route.speeds.length < 10) return '';
                
                const validSpeeds = route.speeds.filter(s => s !== null && s > 0);
                if (validSpeeds.length === 0) return '';
                
                const avgSpeed = validSpeeds.reduce((a, b) => a + b, 0) / validSpeeds.length;
                let text = '';
                
                // Top sustained speed with rolling average
                const rollingWindow = Math.min(10, Math.floor(validSpeeds.length / 10));
                let maxAvgSpeed = 0;
                for (let i = 0; i <= validSpeeds.length - rollingWindow; i++) {
                    const windowSpeeds = validSpeeds.slice(i, i + rollingWindow);
                    const avgWindowSpeed = windowSpeeds.reduce((a, b) => a + b, 0) / windowSpeeds.length;
                    if (avgWindowSpeed > maxAvgSpeed) maxAvgSpeed = avgWindowSpeed;
                }
                
                text += `<p>🚀 Your fastest sustained effort clocked in at <strong>${maxAvgSpeed.toFixed(1)} km/h</strong> (${Utils.formatPace(60 / maxAvgSpeed)} pace), averaged over roughly 30-60 seconds. `;
                const speedDiff = ((maxAvgSpeed - avgSpeed) / avgSpeed) * 100;
                if (speedDiff > 40) {
                    text += `That's ${speedDiff.toFixed(0)}% faster than your average—quite a surge! You clearly had some fast sections where you really opened up the throttle.`;
                } else if (speedDiff > 20) {
                    text += `That's ${speedDiff.toFixed(0)}% quicker than your average pace, showing you had some good speed variations throughout.`;
                } else {
                    text += `This is fairly close to your average, suggesting consistent pacing without dramatic speed changes.`;
                }
                text += '</p>';
                
                // Surge analysis
                const smoothedSpeeds = [];
                const smoothWindow = 3;
                for (let i = 0; i < validSpeeds.length; i++) {
                    const start = Math.max(0, i - Math.floor(smoothWindow / 2));
                    const end = Math.min(validSpeeds.length, i + Math.ceil(smoothWindow / 2));
                    const window = validSpeeds.slice(start, end);
                    smoothedSpeeds.push(window.reduce((a, b) => a + b, 0) / window.length);
                }
                
                let surges = 0;
                let inSurge = false;
                let surgeLength = 0;
                
                for (let i = 1; i < smoothedSpeeds.length; i++) {
                    const change = (smoothedSpeeds[i] - smoothedSpeeds[i-1]) / smoothedSpeeds[i-1];
                    if (change > 0.3) {
                        if (!inSurge) {
                            surgeLength = 1;
                            inSurge = true;
                        } else {
                            surgeLength++;
                        }
                    } else {
                        if (inSurge && surgeLength >= 3) surges++;
                        inSurge = false;
                        surgeLength = 0;
                    }
                }
                if (inSurge && surgeLength >= 3) surges++;
                
                if (surges >= 3 && surges <= 50) {
                    const surgeDensity = surges / (route.stats.distance / 1000);
                    text += `<p>⚡ We detected <strong>${surges} meaningful speed surges</strong> throughout your run`;
                    if (surgeDensity > 1) {
                        text += `—that's more than one per kilometer! Sounds like quite an aggressive race with lots of position changes or tactical moves. Were you battling with someone out there?`;
                    } else if (surgeDensity > 0.5) {
                        text += `. These are significant accelerations where you picked up the pace deliberately—perhaps responding to other runners, hitting downhill sections, or making tactical moves.`;
                    } else {
                        text += `, showing occasional pickups in pace. Could be responding to terrain changes, making tactical moves, or just mixing up your effort level.`;
                    }
                    text += '</p>';
                }
                
                text += `<p><em>Your average speed was ${avgSpeed.toFixed(1)} km/h (${Utils.formatPace(60 / avgSpeed)} pace).</em></p>`;
                
                return text;
            }
            
            generatePaceText(route) {
                if (route.paces.length < 10) return '';
                
                let text = '';
                
                // Split analysis
                const halfwayIndex = Math.floor(route.paces.length / 2);
                const firstHalf = route.paces.slice(0, halfwayIndex).filter(p => p !== null);
                const secondHalf = route.paces.slice(halfwayIndex).filter(p => p !== null);
                
                if (firstHalf.length > 0 && secondHalf.length > 0) {
                    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
                    const diff = ((secondAvg - firstAvg) / firstAvg) * 100;
                    const absDiff = Math.abs(diff);
                    
                    if (absDiff < 2) {
                        text += `<p>🎯 <strong>Nearly perfect pacing!</strong> Your first and second half were within 2% of each other (${Utils.formatPace(firstAvg)} vs ${Utils.formatPace(secondAvg)}). This kind of even split is the hallmark of smart racing—you nailed your pacing strategy.</p>`;
                    } else if (diff < 0) {
                        text += `<p>💪 You ran a <strong>negative split</strong>, finishing ${absDiff.toFixed(1)}% faster than you started (${Utils.formatPace(firstAvg)} → ${Utils.formatPace(secondAvg)}). That's impressive discipline! You either paced conservatively early on or found another gear late in the race. This is usually the sign of a well-executed race plan.</p>`;
                    } else {
                        text += `<p>⚠️ Your second half was ${absDiff.toFixed(1)}% slower than your first (${Utils.formatPace(firstAvg)} → ${Utils.formatPace(secondAvg)}). This positive split is super common, especially in longer races—fatigue catches up with all of us! `;
                        if (absDiff > 15) {
                            text += `The significant fade suggests you might have started too fast. Consider a more conservative early pace next time.`;
                        } else {
                            text += `It's a natural slowdown given the distance and fatigue.`;
                        }
                        text += '</p>';
                    }
                }
                
                // Consistency
                const validPaces = route.paces.filter(p => p !== null && p > 0 && p < 20);
                if (validPaces.length >= 10) {
                    const mean = validPaces.reduce((a, b) => a + b, 0) / validPaces.length;
                    const variance = validPaces.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / validPaces.length;
                    const stdDev = Math.sqrt(variance);
                    const cv = (stdDev / mean) * 100;
                    
                    if (cv < 10) {
                        text += `<p>📊 Your pacing was <strong>remarkably consistent</strong> with less than 10% variation. Like a metronome out there! This level of consistency usually comes from either very flat terrain, excellent pacing discipline, or both.</p>`;
                    } else if (cv < 20) {
                        text += `<p>📊 Your pace showed <strong>moderate variation</strong> (around ${cv.toFixed(0)}% coefficient of variation). This is pretty normal—real-world running involves hills, aid stations, and fatigue, so some variation is expected.</p>`;
                    } else {
                        text += `<p>🎢 Your pace was quite variable (${cv.toFixed(0)}% variation), suggesting either challenging terrain, lots of hills, or some strategic walking breaks. Ultra-distance races often show this pattern—it's about getting to the finish, not maintaining perfect pace.</p>`;
                    }
                }
                
                // Best/worst segments with rolling averages
                const validPacesWithIndex = route.paces.map((p, i) => ({ pace: p, index: i })).filter(p => p.pace !== null && p.pace > 0 && p.pace < 20);
                if (validPacesWithIndex.length >= 10) {
                    let distances = [0];
                    for (let i = 1; i < route.coordinates.length; i++) {
                        distances.push(distances[i-1] + Utils.haversineDistance(route.coordinates[i-1], route.coordinates[i]));
                    }
                    
                    const rollingWindow = Math.min(10, Math.floor(validPacesWithIndex.length / 10));
                    let fastestAvgPace = Infinity;
                    let fastestAvgIndex = 0;
                    
                    for (let i = 0; i <= validPacesWithIndex.length - rollingWindow; i++) {
                        const windowPaces = validPacesWithIndex.slice(i, i + rollingWindow).map(p => p.pace);
                        const avgPace = windowPaces.reduce((a, b) => a + b, 0) / windowPaces.length;
                        if (avgPace < fastestAvgPace) {
                            fastestAvgPace = avgPace;
                            fastestAvgIndex = validPacesWithIndex[i + Math.floor(rollingWindow / 2)].index;
                        }
                    }
                    
                    const fastestDist = distances[fastestAvgIndex];
                    text += `<p>⚡ Your fastest sustained stretch hit <strong>${Utils.formatPace(fastestAvgPace)}</strong> around ${Utils.formatDistance(fastestDist)}. `;
                    if (fastestDist / route.stats.distance < 0.3) {
                        text += `Starting fast and feeling good!`;
                    } else if (fastestDist / route.stats.distance > 0.7) {
                        text += `A strong finish—you must have been feeling good at the end.`;
                    } else {
                        text += `Mid-race surge—nice work!`;
                    }
                    text += '</p>';
                    
                    // Toughest moving section
                    const STOP_THRESHOLD = 12;
                    const movingPaces = validPacesWithIndex.filter(p => p.pace < STOP_THRESHOLD);
                    
                    if (movingPaces.length > rollingWindow) {
                        let slowestAvgPace = 0;
                        let slowestAvgIndex = 0;
                        
                        for (let i = 0; i <= movingPaces.length - rollingWindow; i++) {
                            const windowPaces = movingPaces.slice(i, i + rollingWindow).map(p => p.pace);
                            const avgPace = windowPaces.reduce((a, b) => a + b, 0) / windowPaces.length;
                            if (avgPace > slowestAvgPace) {
                                slowestAvgPace = avgPace;
                                slowestAvgIndex = movingPaces[i + Math.floor(rollingWindow / 2)].index;
                            }
                        }
                        
                        const slowestDist = distances[slowestAvgIndex];
                        text += `<p>🐌 The toughest moving section was around <strong>${Utils.formatDistance(slowestDist)}</strong> where you slowed to ${Utils.formatPace(slowestAvgPace)} while still moving. `;
                        if (slowestDist / route.stats.distance > 0.7) {
                            text += `That late-race grind is real—fatigue and accumulated effort make those final miles tough.`;
                        } else {
                            text += `Could be a hill, headwind, or just a rough patch. It happens!`;
                        }
                        text += '</p>';
                    }
                    
                    // IMPROVED: Longest break detection (same logic as card-based insights)
                    // Method 1: Check for TIME GAPS in GPS data
                    // Method 2: Check for very SLOW PACES
                    
                    let longestBreakSeconds = 0;
                    let longestBreakLocation = 0;
                    let longestBreakType = '';
                    
                    // METHOD 1: Time gaps between GPS points
                    if (route.timestamps && route.timestamps.length > 1) {
                        for (let i = 1; i < route.timestamps.length; i++) {
                            if (route.timestamps[i] && route.timestamps[i-1]) {
                                const gapSeconds = (route.timestamps[i] - route.timestamps[i-1]) / 1000;
                                
                                if (gapSeconds > 60 && gapSeconds < 3600) {
                                    if (gapSeconds > longestBreakSeconds) {
                                        longestBreakSeconds = gapSeconds;
                                        longestBreakLocation = distances[i-1];
                                        longestBreakType = 'gap';
                                    }
                                }
                            }
                        }
                    }
                    
                    // METHOD 3: Zero-distance consecutive points (stationary with GPS still recording)
                    if (route.coordinates && route.coordinates.length > 1 && 
                        route.timestamps && route.timestamps.length > 1) {
                        
                        let currentStationaryStart = -1;
                        let currentStationaryCount = 0;
                        const STATIONARY_THRESHOLD = 0.005; // 5 meters in km
                        
                        for (let i = 1; i < route.coordinates.length; i++) {
                            const dist = Utils.haversineDistance(
                                route.coordinates[i-1], 
                                route.coordinates[i]
                            );
                            
                            if (dist < STATIONARY_THRESHOLD) {
                                if (currentStationaryStart === -1) {
                                    currentStationaryStart = i - 1;
                                    currentStationaryCount = 2;
                                } else {
                                    currentStationaryCount++;
                                }
                            } else {
                                if (currentStationaryCount >= 3 && currentStationaryStart >= 0) {
                                    if (route.timestamps[currentStationaryStart] && 
                                        route.timestamps[currentStationaryStart + currentStationaryCount - 1]) {
                                        
                                        const startTime = route.timestamps[currentStationaryStart];
                                        const endTime = route.timestamps[currentStationaryStart + currentStationaryCount - 1];
                                        const durationSeconds = (endTime - startTime) / 1000;
                                        
                                        if (durationSeconds > 60 && durationSeconds < 3600) {
                                            if (durationSeconds > longestBreakSeconds) {
                                                longestBreakSeconds = durationSeconds;
                                                longestBreakLocation = distances[currentStationaryStart];
                                                longestBreakType = 'stationary';
                                            }
                                        }
                                    }
                                }
                                
                                currentStationaryStart = -1;
                                currentStationaryCount = 0;
                            }
                        }
                        
                        // Check final segment
                        if (currentStationaryCount >= 3 && currentStationaryStart >= 0) {
                            if (route.timestamps[currentStationaryStart] && 
                                route.timestamps[currentStationaryStart + currentStationaryCount - 1]) {
                                
                                const startTime = route.timestamps[currentStationaryStart];
                                const endTime = route.timestamps[currentStationaryStart + currentStationaryCount - 1];
                                const durationSeconds = (endTime - startTime) / 1000;
                                
                                if (durationSeconds > 60 && durationSeconds < 3600) {
                                    if (durationSeconds > longestBreakSeconds) {
                                        longestBreakSeconds = durationSeconds;
                                        longestBreakLocation = distances[currentStationaryStart];
                                        longestBreakType = 'stationary';
                                    }
                                }
                            }
                        }
                    }
                    
                    // METHOD 2: Consecutive very slow paces
                    const stoppedPaces = validPacesWithIndex.filter(p => p.pace >= STOP_THRESHOLD);
                    if (stoppedPaces.length > 0) {
                        let currentStopStart = -1;
                        let currentStopLength = 0;
                        
                        for (let i = 0; i < route.paces.length; i++) {
                            if (route.paces[i] !== null && route.paces[i] >= STOP_THRESHOLD) {
                                if (currentStopStart === -1) {
                                    currentStopStart = i;
                                    currentStopLength = 1;
                                } else {
                                    currentStopLength++;
                                }
                            } else {
                                if (currentStopLength >= 3) {
                                    let durationSeconds = 0;
                                    if (route.timestamps && route.timestamps[currentStopStart] && 
                                        route.timestamps[currentStopStart + currentStopLength - 1]) {
                                        const startTime = route.timestamps[currentStopStart];
                                        const endTime = route.timestamps[currentStopStart + currentStopLength - 1];
                                        durationSeconds = (endTime - startTime) / 1000;
                                    } else {
                                        durationSeconds = currentStopLength * 4;
                                    }
                                    
                                    if (durationSeconds > longestBreakSeconds) {
                                        longestBreakSeconds = durationSeconds;
                                        longestBreakLocation = distances[currentStopStart];
                                        longestBreakType = 'slow';
                                    }
                                }
                                currentStopStart = -1;
                                currentStopLength = 0;
                            }
                        }
                        
                        // Check final segment
                        if (currentStopLength >= 3) {
                            let durationSeconds = 0;
                            if (route.timestamps && route.timestamps[currentStopStart] && 
                                route.timestamps[currentStopStart + currentStopLength - 1]) {
                                const startTime = route.timestamps[currentStopStart];
                                const endTime = route.timestamps[currentStopStart + currentStopLength - 1];
                                durationSeconds = (endTime - startTime) / 1000;
                            } else {
                                durationSeconds = currentStopLength * 4;
                            }
                            
                            if (durationSeconds > longestBreakSeconds) {
                                longestBreakSeconds = durationSeconds;
                                longestBreakLocation = distances[currentStopStart];
                                longestBreakType = 'slow';
                            }
                        }
                    }
                    
                    // Report the longest break
                    if (longestBreakSeconds >= 30) {
                        text += `<p>☕ You took your longest break around <strong>${Utils.formatDistance(longestBreakLocation)}</strong> for about ${Utils.formatBreakDuration(longestBreakSeconds)}. `;
                        
                        if (longestBreakType === 'gap' || longestBreakType === 'stationary') {
                            text += `Your GPS stopped recording during this time—you were likely sitting completely still`;
                            if (longestBreakSeconds > 300) {
                                text += `, taking a proper rest. That's a solid 5+ minute stop, probably a major aid station where you took time to refuel and regroup. Smart racing includes good aid station efficiency!`;
                            } else if (longestBreakSeconds > 120) {
                                text += `. A few minutes of complete rest—probably an aid station where you took time to sort yourself out.`;
                            } else {
                                text += `. Quick stop—maybe bathroom break or grabbing something from crew.`;
                            }
                        } else {
                            // Slow pace type
                            if (longestBreakSeconds > 180) {
                                text += `That's a solid stop—probably a major aid station where you took time to refuel and regroup. Smart racing includes good aid station efficiency!`;
                            } else if (longestBreakSeconds > 60) {
                                text += `Likely an aid station stop or quick breather. Nothing wrong with that in a long race!`;
                            } else {
                                text += `Quick stop—grab and go style!`;
                            }
                        }
                        text += '</p>';
                    }
                }
                
                return text;
            }
            
            generateCadenceText(route) {
                if (route.cadences.length < 10) return '';
                
                const validCadence = route.cadences.filter(c => c !== null && c > 0);
                if (validCadence.length === 0) return '';
                
                const avgCadence = validCadence.reduce((a, b) => a + b, 0) / validCadence.length;
                let text = '';
                
                // Find optimal cadence during best paces
                if (route.paces.length > 10) {
                    const validData = route.paces.map((p, i) => ({
                        pace: p,
                        cadence: route.cadences[i]
                    })).filter(d => d.pace !== null && d.cadence !== null && d.pace > 0);
                    
                    if (validData.length > 10) {
                        const sorted = [...validData].sort((a, b) => a.pace - b.pace);
                        const topPaces = sorted.slice(0, Math.floor(sorted.length * 0.1));
                        const bestCadence = topPaces.reduce((a, b) => a + b.cadence, 0) / topPaces.length;
                        
                        text += `<p>👟 During your fastest sections, you averaged <strong>${Math.round(bestCadence)} steps per minute</strong>. `;
                        
                        if (bestCadence > 180) {
                            text += `That's a really high cadence—you're a quick-stepper! This rapid turnover is often seen in efficient runners, though it can be tiring to maintain over long distances.`;
                        } else if (bestCadence > 170) {
                            text += `This is right in the sweet spot that many coaches recommend. Quick, light steps tend to be more efficient and reduce injury risk.`;
                        } else if (bestCadence > 160) {
                            text += `This is a pretty typical cadence for distance running. Nothing wrong with this at all, especially on trails or in ultras where terrain matters more than turnover.`;
                        } else if (bestCadence > 140) {
                            text += `This is on the lower side for running cadence. You might benefit from working on quicker leg turnover, though in ultras or on technical trails, this can be perfectly normal.`;
                        } else {
                            text += `This is quite low for running—either you're taking very long strides, doing a lot of hiking, or your watch might not be picking up cadence consistently. Ultra runners often see lower cadence due to walking breaks and technical terrain.`;
                        }
                        text += '</p>';
                        
                        const cadenceDrop = avgCadence - bestCadence;
                        if (Math.abs(cadenceDrop) > 10) {
                            text += `<p>📉 Your cadence dropped by about ${Math.abs(cadenceDrop).toFixed(0)} spm from your fastest sections to your overall average. This is pretty normal in longer races as fatigue sets in—your form typically breaks down a bit and stride rate drops.</p>`;
                        }
                    }
                }
                
                text += `<p><em>Your overall average cadence was ${Math.round(avgCadence)} spm.</em></p>`;
                
                return text;
            }
            
            generateElevationText(route) {
                if (route.elevations.length < 10) return '';
                
                const validElev = route.elevations.filter(e => e !== null);
                if (validElev.length === 0) return '';
                
                const maxElev = Math.max(...validElev);
                const minElev = Math.min(...validElev);
                const netElev = validElev[validElev.length - 1] - validElev[0];
                let text = '';
                
                // Net elevation
                if (Math.abs(netElev) > 10) {
                    const direction = netElev > 0 ? 'uphill' : 'downhill';
                    const opposite = netElev > 0 ? 'downhill' : 'uphill';
                    text += `<p>⛰️ Overall, this route had a <strong>net ${Math.abs(netElev).toFixed(0)}m ${direction}</strong> bias. `;
                    
                    if (Math.abs(netElev) > 100) {
                        text += `That's significant! You finished ${Math.abs(netElev).toFixed(0)}m ${direction === 'uphill' ? 'higher' : 'lower'} than you started. `;
                        if (netElev > 0) {
                            text += `All that climbing at the end makes for a tough finish.`;
                        } else {
                            text += `That ${opposite} start is work you'll pay back on the downhill finish!`;
                        }
                    } else {
                        text += `While there was some elevation change, it's relatively balanced overall. What goes up must come down!`;
                    }
                    text += '</p>';
                }
                
                // Elevation range
                const elevRange = maxElev - minElev;
                text += `<p>📈 The elevation ranged from <strong>${minElev.toFixed(0)}m to ${maxElev.toFixed(0)}m</strong>, giving you ${elevRange.toFixed(0)}m of total elevation variation. `;
                
                if (elevRange > 500) {
                    text += `That's some serious vertical! This route had major climbs and descents—definitely a challenging elevation profile.`;
                } else if (elevRange > 200) {
                    text += `Moderate elevation changes—enough to make things interesting with some decent hills to test your climbing legs.`;
                } else if (elevRange > 50) {
                    text += `Some gentle rolling terrain, but nothing too dramatic. A fairly runnable elevation profile.`;
                } else {
                    text += `Pretty flat overall! When the biggest change is only ${elevRange.toFixed(0)}m, you can focus on pace rather than power hiking.`;
                }
                text += '</p>';
                
                // Elevation gain context
                if (route.stats.elevationGain) {
                    const gainPerKm = route.stats.elevationGain / (route.stats.distance / 1000);
                    text += `<p>🏔️ <em>Total elevation gain: ${route.stats.elevationGain.toFixed(0)}m (roughly ${gainPerKm.toFixed(0)}m per km on average)</em></p>`;
                }
                
                return text;
            }
            
            closeInsightsModal() {
                document.getElementById('insightsModal').classList.remove('show');
                this.currentInsightsRoute = null;
                this.currentInsightsIndex = null;
                if (this.insightsChartManager) {
                    this.insightsChartManager.zoomState = null;
                    // Hide crosshair
                    const crosshair = document.getElementById('insightsCrosshair');
                    if (crosshair) {
                        crosshair.style.display = 'none';
                    }
                }
            }
            
            generateInsights(route) {
                const insights = [];
                
                // Split Analysis
                if (route.stats.duration && route.paces.length > 10) {
                    const splitInsight = this.calculateSplitAnalysis(route);
                    if (splitInsight) insights.push(splitInsight);
                }
                
                // Pace Consistency
                if (route.paces.length > 10) {
                    const consistencyInsight = this.calculateConsistency(route);
                    if (consistencyInsight) insights.push(consistencyInsight);
                }
                
                // Best/Worst segments
                if (route.paces.length > 10) {
                    const segmentInsights = this.calculateBestWorstSegments(route);
                    insights.push(...segmentInsights);
                }
                
                // Heart Rate Insights
                if (route.heartRates.length > 10) {
                    const hrInsights = this.calculateHeartRateInsights(route);
                    insights.push(...hrInsights);
                }
                
                // Elevation Insights
                if (route.elevations.length > 10) {
                    const elevInsights = this.calculateElevationInsights(route);
                    insights.push(...elevInsights);
                }
                
                // Speed insights
                if (route.speeds.length > 10) {
                    const speedInsights = this.calculateSpeedInsights(route);
                    insights.push(...speedInsights);
                }
                
                // Cadence insights
                if (route.cadences.length > 10) {
                    const cadenceInsights = this.calculateCadenceInsights(route);
                    insights.push(...cadenceInsights);
                }
                
                // Quirky stats
                const quirkyStats = this.calculateQuirkyStats(route);
                insights.push(...quirkyStats);
                
                return insights;
            }
            
            calculateSplitAnalysis(route) {
                const halfwayIndex = Math.floor(route.paces.length / 2);
                const firstHalf = route.paces.slice(0, halfwayIndex).filter(p => p !== null);
                const secondHalf = route.paces.slice(halfwayIndex).filter(p => p !== null);
                
                if (firstHalf.length === 0 || secondHalf.length === 0) return null;
                
                const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
                
                const diff = ((secondAvg - firstAvg) / firstAvg) * 100;
                const absDiff = Math.abs(diff);
                
                if (absDiff < 2) {
                    return this.createInsightCard('neutral', '🎯 Even Split', 'Perfect Execution', 
                        `Remarkably consistent pacing! First half: ${Utils.formatPace(firstAvg)}, Second half: ${Utils.formatPace(secondAvg)}`);
                } else if (diff < 0) {
                    return this.createInsightCard('positive', '💪 Negative Split', `${absDiff.toFixed(1)}% Faster`, 
                        `Strong finish! Second half was ${absDiff.toFixed(1)}% faster (${Utils.formatPace(firstAvg)} → ${Utils.formatPace(secondAvg)})`);
                } else {
                    return this.createInsightCard('negative', '⚠️ Positive Split', `${absDiff.toFixed(1)}% Slower`, 
                        `Slowed down in the second half by ${absDiff.toFixed(1)}% (${Utils.formatPace(firstAvg)} → ${Utils.formatPace(secondAvg)})`);
                }
            }
            
            calculateConsistency(route) {
                const validPaces = route.paces.filter(p => p !== null && p > 0 && p < 20);
                if (validPaces.length < 10) return null;
                
                const mean = validPaces.reduce((a, b) => a + b, 0) / validPaces.length;
                const variance = validPaces.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / validPaces.length;
                const stdDev = Math.sqrt(variance);
                const cv = (stdDev / mean) * 100;
                
                let type, title, value, desc;
                if (cv < 10) {
                    type = 'positive';
                    title = '🎯 Steady Eddie';
                    value = `${(100 - cv).toFixed(0)}% Consistent`;
                    desc = 'Excellent pacing! Your pace varied by less than 10%.';
                } else if (cv < 20) {
                    type = 'neutral';
                    title = '📊 Moderate Variation';
                    value = `${(100 - cv).toFixed(0)}% Consistent`;
                    desc = 'Decent pacing with some variation throughout the run.';
                } else {
                    type = 'negative';
                    title = '🎢 Rollercoaster Run';
                    value = `${cv.toFixed(0)}% Variation`;
                    desc = 'Highly variable pace - consider working on consistency.';
                }
                
                return this.createInsightCard(type, title, value, desc);
            }
            
            calculateBestWorstSegments(route) {
                const insights = [];
                if (!route.paces || route.paces.length < 10) return insights;
                
                const totalDistanceKm = route.stats.distance / 1000;
                let maxRealisticPace;
                
                if (totalDistanceKm > 80) {
                    maxRealisticPace = 3.5;
                } else if (totalDistanceKm > 50) {
                    maxRealisticPace = 3.0;
                } else if (totalDistanceKm > 30) {
                    maxRealisticPace = 2.5;
                } else if (totalDistanceKm > 15) {
                    maxRealisticPace = 2.3;
                } else {
                    maxRealisticPace = 2.0;
                }
                
                // IMPROVED: Apply comprehensive GPS cleaning first
                const cleaned = Utils.cleanGPSData(
                    route.speeds, 
                    route.paces, 
                    route.coordinates, 
                    route.timestamps,
                    totalDistanceKm > 50 ? 20 : 25
                );
                
                // DEBUG: Log filtering results
                console.log('🔍 GPS Cleaning Results:');
                console.log(`  Total points: ${route.speeds.length}`);
                console.log(`  Valid after cleaning: ${cleaned.validIndices.length}`);
                console.log(`  Filtered out: ${route.speeds.length - cleaned.validIndices.length} (${((route.speeds.length - cleaned.validIndices.length) / route.speeds.length * 100).toFixed(1)}%)`);
                
                // DEBUG: Show speed distribution
                const cleanedSpeeds = cleaned.validIndices.map(i => route.speeds[i]).filter(s => s > 0);
                if (cleanedSpeeds.length > 0) {
                    const sortedSpeeds = [...cleanedSpeeds].sort((a, b) => a - b);
                    console.log('📊 Speed Distribution (after cleaning):');
                    console.log(`  Min: ${sortedSpeeds[0].toFixed(1)} km/h`);
                    console.log(`  10th percentile: ${sortedSpeeds[Math.floor(sortedSpeeds.length * 0.1)].toFixed(1)} km/h`);
                    console.log(`  25th percentile: ${sortedSpeeds[Math.floor(sortedSpeeds.length * 0.25)].toFixed(1)} km/h`);
                    console.log(`  Median: ${sortedSpeeds[Math.floor(sortedSpeeds.length * 0.5)].toFixed(1)} km/h`);
                    console.log(`  75th percentile: ${sortedSpeeds[Math.floor(sortedSpeeds.length * 0.75)].toFixed(1)} km/h`);
                    console.log(`  90th percentile: ${sortedSpeeds[Math.floor(sortedSpeeds.length * 0.9)].toFixed(1)} km/h`);
                    console.log(`  95th percentile: ${sortedSpeeds[Math.floor(sortedSpeeds.length * 0.95)].toFixed(1)} km/h`);
                    console.log(`  99th percentile: ${sortedSpeeds[Math.floor(sortedSpeeds.length * 0.99)].toFixed(1)} km/h`);
                    console.log(`  Max: ${sortedSpeeds[sortedSpeeds.length - 1].toFixed(1)} km/h`);
                }
                
                const validPaces = route.paces.map((p, i) => ({ pace: p, index: i }))
                    .filter((p, i) => 
                        p.pace !== null && 
                        !isNaN(p.pace) && 
                        isFinite(p.pace) && 
                        p.pace > maxRealisticPace && 
                        p.pace < 20 &&
                        cleaned.validIndices.includes(i) // Use cleaned indices
                    );
                
                console.log(`  Valid paces for analysis: ${validPaces.length}`);
                
                if (validPaces.length < 10) return insights;
                
                // Cache distances array on route object to avoid recalculating
                if (!route._cachedDistances) {
                    route._cachedDistances = [0];
                    for (let i = 1; i < route.coordinates.length; i++) {
                        route._cachedDistances.push(route._cachedDistances[i-1] + Utils.haversineDistance(route.coordinates[i-1], route.coordinates[i]));
                    }
                }
                const distances = route._cachedDistances;
                
                // Calculate MEDIAN pace (more robust than mean)
                const allPaces = route.paces.filter((p, i) => 
                    p > 0 && p < 20 && cleaned.validIndices.includes(i)
                );
                const routeMedianPace = Utils.median(allPaces);
                
                const baseWindow = totalDistanceKm > 50 ? 15 : 10;
                const rollingWindow = Math.max(5, Math.min(baseWindow, Math.floor(validPaces.length / 10)));
                let fastestAvgPace = Infinity;
                let fastestAvgIndex = 0;
                
                for (let i = 0; i <= validPaces.length - rollingWindow; i++) {
                    const windowPaces = validPaces.slice(i, i + rollingWindow).map(p => p.pace);
                    
                    // IMPROVED: Use MAD-based outlier filtering instead of simple trimming
                    const filtered = Utils.filterOutliersMAD(windowPaces, 2.5);
                    
                    if (filtered.length >= 5) {
                        // IMPROVED: Use median instead of mean for rolling window
                        const medianPace = Utils.median(filtered);
                        const speedupRatio = routeMedianPace / medianPace;
                        const maxSpeedupRatio = totalDistanceKm > 50 ? 1.5 : 1.8;
                        
                        if (medianPace < fastestAvgPace && speedupRatio <= maxSpeedupRatio) {
                            fastestAvgPace = medianPace;
                            fastestAvgIndex = validPaces[i + Math.floor(rollingWindow / 2)].index;
                        }
                    }
                }
                
                if (fastestAvgPace !== Infinity && fastestAvgPace >= maxRealisticPace && fastestAvgPace < 20) {
                    const fastestDist = distances[fastestAvgIndex];
                    
                    // DEBUG: Show comparison
                    console.log('⚡ Fastest Sustained Pace:');
                    console.log(`  Route median pace: ${routeMedianPace.toFixed(2)} min/km`);
                    console.log(`  Fastest window pace (median): ${fastestAvgPace.toFixed(2)} min/km`);
                    console.log(`  Speedup ratio: ${(routeMedianPace / fastestAvgPace).toFixed(2)}x`);
                    
                    insights.push(this.createInsightCard('positive', '⚡ Fastest Sustained Pace', Utils.formatPace(fastestAvgPace), 
                        `Peak performance around ${Utils.formatDistance(fastestDist)} (averaged over ${rollingWindow} points)`));
                }
                
                // Find toughest MOVING section
                const STOP_THRESHOLD = 12;
                const movingPaces = validPaces.filter(p => p.pace < STOP_THRESHOLD);
                
                if (movingPaces.length > rollingWindow) {
                    let slowestAvgPace = 0;
                    let slowestAvgIndex = 0;
                    
                    for (let i = 0; i <= movingPaces.length - rollingWindow; i++) {
                        const windowPaces = movingPaces.slice(i, i + rollingWindow).map(p => p.pace);
                        const avgPace = windowPaces.reduce((a, b) => a + b, 0) / windowPaces.length;
                        if (avgPace > slowestAvgPace) {
                            slowestAvgPace = avgPace;
                            slowestAvgIndex = movingPaces[i + Math.floor(rollingWindow / 2)].index;
                        }
                    }
                    
                    if (slowestAvgPace > 0 && slowestAvgPace < 20) {
                        const slowestDist = distances[slowestAvgIndex];
                        insights.push(this.createInsightCard('neutral', '🐌 Toughest Moving Section', Utils.formatPace(slowestAvgPace), 
                            `The grind was real around ${Utils.formatDistance(slowestDist)} (while still moving)`));
                    }
                }
                
                // Detect breaks (keeping existing logic but adding validation)
                
                let longestBreakSeconds = 0;
                let longestBreakLocation = 0;
                let longestBreakType = '';
                
                // METHOD 1: Time gaps between GPS points (this catches sitting still)
                if (route.timestamps && route.timestamps.length > 1) {
                    for (let i = 1; i < route.timestamps.length; i++) {
                        if (route.timestamps[i] && route.timestamps[i-1]) {
                            const gapSeconds = (route.timestamps[i] - route.timestamps[i-1]) / 1000;
                            
                            // If gap is > 60 seconds, it's likely a stop (normal GPS sampling is 1-5 seconds)
                            if (gapSeconds > 60 && gapSeconds < 3600) { // Between 1 minute and 1 hour (sanity check)
                                if (gapSeconds > longestBreakSeconds) {
                                    longestBreakSeconds = gapSeconds;
                                    longestBreakLocation = distances[i-1]; // Location before the gap
                                    longestBreakType = 'gap';
                                }
                            }
                        }
                    }
                }
                
                // METHOD 3: Speed-based stationary detection
                // Instead of looking at distance between points, look at actual speed/movement
                if (route.speeds && route.speeds.length > 10 && 
                    route.timestamps && route.timestamps.length > 1) {
                    
                    let currentStationaryStart = -1;
                    let currentStationaryCount = 0;
                    const SPEED_THRESHOLD = 0.3; // km/h - essentially stopped (slower than 20 min/km)
                    
                    for (let i = 0; i < route.speeds.length; i++) {
                        const speed = route.speeds[i];
                        
                        // If speed is very low or zero, consider it stationary
                        if (speed !== null && speed < SPEED_THRESHOLD) {
                            if (currentStationaryStart === -1) {
                                currentStationaryStart = i;
                                currentStationaryCount = 1;
                            } else {
                                currentStationaryCount++;
                            }
                        } else {
                            // End of stationary sequence
                            if (currentStationaryCount >= 10 && currentStationaryStart >= 0) {
                                // Calculate duration of stationary period
                                if (route.timestamps[currentStationaryStart] && 
                                    route.timestamps[currentStationaryStart + currentStationaryCount - 1]) {
                                    
                                    const startTime = route.timestamps[currentStationaryStart];
                                    const endTime = route.timestamps[currentStationaryStart + currentStationaryCount - 1];
                                    const durationSeconds = (endTime - startTime) / 1000;
                                    const location = distances[currentStationaryStart];
                                    
                                    // Only consider stops > 60 seconds and < 1 hour
                                    if (durationSeconds > 60 && durationSeconds < 3600) {
                                        if (durationSeconds > longestBreakSeconds) {
                                            longestBreakSeconds = durationSeconds;
                                            longestBreakLocation = location;
                                            longestBreakType = 'stationary';
                                        }
                                    }
                                }
                            }
                            
                            currentStationaryStart = -1;
                            currentStationaryCount = 0;
                        }
                    }
                    
                    // Check final segment
                    if (currentStationaryCount >= 10 && currentStationaryStart >= 0) {
                        if (route.timestamps[currentStationaryStart] && 
                            route.timestamps[currentStationaryStart + currentStationaryCount - 1]) {
                            
                            const startTime = route.timestamps[currentStationaryStart];
                            const endTime = route.timestamps[currentStationaryStart + currentStationaryCount - 1];
                            const durationSeconds = (endTime - startTime) / 1000;
                            const location = distances[currentStationaryStart];
                            
                            if (durationSeconds > 60 && durationSeconds < 3600) {
                                if (durationSeconds > longestBreakSeconds) {
                                    longestBreakSeconds = durationSeconds;
                                    longestBreakLocation = location;
                                    longestBreakType = 'stationary';
                                }
                            }
                        }
                    }
                }
                
                // METHOD 2: Consecutive very slow paces (walking at aid station)
                const stoppedPaces = validPaces.filter(p => p.pace >= STOP_THRESHOLD);
                if (stoppedPaces.length > 0) {
                    let currentStopStart = -1;
                    let currentStopLength = 0;
                    
                    for (let i = 0; i < route.paces.length; i++) {
                        if (route.paces[i] !== null && route.paces[i] >= STOP_THRESHOLD) {
                            if (currentStopStart === -1) {
                                currentStopStart = i;
                                currentStopLength = 1;
                            } else {
                                currentStopLength++;
                            }
                        } else {
                            // End of slow pace sequence
                            if (currentStopLength >= 3) {
                                // Calculate duration of this slow pace period
                                let durationSeconds = 0;
                                if (route.timestamps && route.timestamps[currentStopStart] && 
                                    route.timestamps[currentStopStart + currentStopLength - 1]) {
                                    const startTime = route.timestamps[currentStopStart];
                                    const endTime = route.timestamps[currentStopStart + currentStopLength - 1];
                                    durationSeconds = (endTime - startTime) / 1000;
                                } else {
                                    durationSeconds = currentStopLength * 4; // estimate
                                }
                                
                                // Check if this is longer than our current longest break
                                if (durationSeconds > longestBreakSeconds) {
                                    longestBreakSeconds = durationSeconds;
                                    longestBreakLocation = distances[currentStopStart];
                                    longestBreakType = 'slow';
                                }
                            }
                            currentStopStart = -1;
                            currentStopLength = 0;
                        }
                    }
                    
                    // Check final segment
                    if (currentStopLength >= 3) {
                        let durationSeconds = 0;
                        if (route.timestamps && route.timestamps[currentStopStart] && 
                            route.timestamps[currentStopStart + currentStopLength - 1]) {
                            const startTime = route.timestamps[currentStopStart];
                            const endTime = route.timestamps[currentStopStart + currentStopLength - 1];
                            durationSeconds = (endTime - startTime) / 1000;
                        } else {
                            durationSeconds = currentStopLength * 4;
                        }
                        
                        if (durationSeconds > longestBreakSeconds) {
                            longestBreakSeconds = durationSeconds;
                            longestBreakLocation = distances[currentStopStart];
                            longestBreakType = 'slow';
                        }
                    }
                }
                
                // Report the longest break found by either method
                if (longestBreakSeconds >= 30) { // Only report if >= 30 seconds
                    const breakDescription = (longestBreakType === 'gap' || longestBreakType === 'stationary')
                        ? 'GPS stopped recording—you were likely sitting still'
                        : 'Walking very slowly or stopped';
                    
                    insights.push(this.createInsightCard('neutral', '☕ Longest Break', Utils.formatBreakDuration(longestBreakSeconds), 
                        `Around ${Utils.formatDistance(longestBreakLocation)}. ${breakDescription}.`));
                }
                
                return insights;
            }
            
            calculateHeartRateInsights(route) {
                const insights = [];
                if (!route.heartRates || route.heartRates.length < 10) return insights;
                
                const validHR = route.heartRates.filter(hr => hr !== null && !isNaN(hr) && isFinite(hr) && hr >= 30 && hr <= 220);
                if (validHR.length < 10) return insights;
                
                const avgHR = validHR.reduce((a, b) => a + b, 0) / validHR.length;
                const maxHR = Math.max(...validHR);
                const minHR = Math.min(...validHR);
                
                // HR Drift
                const firstQuarter = validHR.slice(0, Math.max(1, Math.floor(validHR.length / 4)));
                const lastQuarter = validHR.slice(-Math.max(1, Math.floor(validHR.length / 4)));
                
                if (firstQuarter.length > 0 && lastQuarter.length > 0) {
                    const firstAvg = firstQuarter.reduce((a, b) => a + b, 0) / firstQuarter.length;
                    const lastAvg = lastQuarter.reduce((a, b) => a + b, 0) / lastQuarter.length;
                    const drift = lastAvg - firstAvg;
                    
                    if (Math.abs(drift) > 5) {
                        const type = drift > 10 ? 'negative' : 'neutral';
                        const driftText = drift > 0 ? `+${drift.toFixed(0)}` : drift.toFixed(0);
                        insights.push(this.createInsightCard(type, '❤️ Cardiac Drift', `${driftText} bpm`, 
                            `Heart rate ${drift > 0 ? 'increased' : 'decreased'} by ${Math.abs(drift).toFixed(0)} bpm from start to finish. ${drift > 10 ? 'Consider hydration and pacing.' : 'Normal for longer efforts.'}`));
                    }
                }
                
                // Peak effort
                if (maxHR >= 30 && maxHR <= 220) {
                    insights.push(this.createInsightCard('neutral', '📈 Peak Effort', `${Math.round(maxHR)} bpm`, 
                        `Maximum heart rate reached during the run`));
                }
                
                return insights;
            }
            
            calculateElevationInsights(route) {
                const insights = [];
                const validElev = route.elevations.filter(e => e !== null);
                if (validElev.length < 10) return insights;
                
                const maxElev = Math.max(...validElev);
                const minElev = Math.min(...validElev);
                
                // Find biggest climb
                let maxClimb = 0;
                let maxClimbStart = 0;
                let currentClimb = 0;
                let climbStart = 0;
                
                for (let i = 1; i < validElev.length; i++) {
                    const change = validElev[i] - validElev[i-1];
                    if (change > 0) {
                        if (currentClimb === 0) climbStart = i;
                        currentClimb += change;
                    } else {
                        if (currentClimb > maxClimb) {
                            maxClimb = currentClimb;
                            maxClimbStart = climbStart;
                        }
                        currentClimb = 0;
                    }
                }
                
                if (maxClimb > 20) {
                    let distances = [0];
                    for (let i = 1; i < route.coordinates.length; i++) {
                        distances.push(distances[i-1] + Utils.haversineDistance(route.coordinates[i-1], route.coordinates[i]));
                    }
                    const climbDist = distances[Math.min(maxClimbStart, distances.length - 1)];
                    
                    insights.push(this.createInsightCard('neutral', '🏔️ Biggest Climb', `${maxClimb.toFixed(0)}m`, 
                        `Conquered at ${Utils.formatDistance(climbDist)}`));
                }
                
                // Net elevation
                const netElev = validElev[validElev.length - 1] - validElev[0];
                if (Math.abs(netElev) > 10) {
                    const type = netElev < 0 ? 'positive' : 'neutral';
                    const direction = netElev < 0 ? 'downhill' : 'uphill';
                    insights.push(this.createInsightCard(type, `${netElev < 0 ? '⬇️' : '⬆️'} Net ${direction.charAt(0).toUpperCase() + direction.slice(1)}`, 
                        `${Math.abs(netElev).toFixed(0)}m`, 
                        `Overall ${direction} advantage of ${Math.abs(netElev).toFixed(0)}m`));
                }
                
                return insights;
            }
            
            calculateSpeedInsights(route) {
                const insights = [];
                
                // Validate we have speed and timestamp data
                if (!route.speeds || route.speeds.length < 10 || !route.timestamps || route.timestamps.length < 10) {
                    return insights;
                }
                
                // CONTEXT-AWARE SPEED CAPS based on run distance
                const totalDistanceKm = route.stats.distance / 1000;
                let maxSustainableSpeed; // km/h
                let maxGpsThreshold; // km/h
                
                if (totalDistanceKm > 80) {
                    // Ultra 100K+: Max realistic sustained speed ~17 km/h (3:30/km)
                    maxSustainableSpeed = 17;
                    maxGpsThreshold = 20;
                } else if (totalDistanceKm > 50) {
                    // Ultra 50K-100K: Max ~20 km/h (3:00/km)
                    maxSustainableSpeed = 20;
                    maxGpsThreshold = 24;
                } else if (totalDistanceKm > 30) {
                    // Marathon+: Max ~24 km/h (2:30/km)
                    maxSustainableSpeed = 24;
                    maxGpsThreshold = 28;
                } else if (totalDistanceKm > 15) {
                    // Half Marathon: Max ~26 km/h (2:18/km)
                    maxSustainableSpeed = 26;
                    maxGpsThreshold = 30;
                } else {
                    // Shorter runs: Allow fastest speeds
                    maxSustainableSpeed = 25;
                    maxGpsThreshold = 30;
                }
                
                // IMPROVED: Apply comprehensive GPS cleaning
                const cleaned = Utils.cleanGPSData(
                    route.speeds, 
                    route.paces, 
                    route.coordinates, 
                    route.timestamps,
                    maxGpsThreshold
                );
                
                // First pass: filter out obvious GPS spikes using cleaned indices
                const validSpeeds = route.speeds
                    .map((s, i) => ({ speed: s, index: i }))
                    .filter(item => 
                        item.speed !== null && 
                        !isNaN(item.speed) && 
                        isFinite(item.speed) && 
                        item.speed > 0 && 
                        item.speed < maxGpsThreshold &&
                        cleaned.validIndices.includes(item.index)
                    )
                    .map(item => item.speed);
                
                if (validSpeeds.length < 10) return insights;
                
                // IMPROVED: Calculate median speed for comparison (more robust)
                const medianSpeed = Utils.median(validSpeeds);
                
                // Calculate top sustained speed over ACTUAL TIME (30 seconds)
                // With IMPROVED outlier filtering
                const TARGET_DURATION_SECONDS = 30;
                let maxAvgSpeed = 0;
                let maxAvgSpeedPoints = 0;
                
                // Only analyze if we have timestamps
                if (route.timestamps && route.timestamps.length === route.speeds.length) {
                    // Sample every 10th point to avoid performance issues on long routes
                    const sampleRate = Math.max(1, Math.floor(route.speeds.length / 1000));
                    
                    for (let i = 0; i < route.speeds.length - 5; i += sampleRate) {
                        if (!route.timestamps[i] || !route.speeds[i]) continue;
                        if (!cleaned.validIndices.includes(i)) continue; // Skip invalid points
                        
                        // Find points within next 30 seconds
                        let j = i + 1;
                        const windowSpeeds = [];
                        
                        // Add first point if it's reasonable
                        if (route.speeds[i] > 0 && route.speeds[i] < maxGpsThreshold) {
                            windowSpeeds.push(route.speeds[i]);
                        }
                        
                        while (j < route.speeds.length && route.timestamps[j]) {
                            const elapsedSeconds = (route.timestamps[j] - route.timestamps[i]) / 1000;
                            
                            if (elapsedSeconds > TARGET_DURATION_SECONDS + 5) break;
                            
                            // Only include cleaned valid points
                            if (cleaned.validIndices.includes(j) &&
                                route.speeds[j] !== null && 
                                !isNaN(route.speeds[j]) && 
                                route.speeds[j] > 0 && 
                                route.speeds[j] < maxGpsThreshold) {
                                windowSpeeds.push(route.speeds[j]);
                            }
                            
                            // Check if we're in the 25-35 second window
                            if (elapsedSeconds >= TARGET_DURATION_SECONDS - 5 && elapsedSeconds <= TARGET_DURATION_SECONDS + 5) {
                                if (windowSpeeds.length >= 10) {
                                    
                                    // IMPROVED: Use MAD-based filtering instead of simple trimming
                                    const filtered = Utils.filterOutliersMAD(windowSpeeds, 2.5);
                                    
                                    if (filtered.length >= 5) {
                                        // IMPROVED: Use median for sustained speed
                                        const medianWindowSpeed = Utils.median(filtered);
                                        
                                        const maxSpeedupRatio = totalDistanceKm > 50 ? 1.6 : 2.2;
                                        const speedupRatio = medianWindowSpeed / medianSpeed;
                                        
                                        const cappedSpeed = Math.min(medianWindowSpeed, maxSustainableSpeed);
                                        
                                        // DEBUG: Log rejected windows
                                        if (medianWindowSpeed > maxSustainableSpeed) {
                                            console.log(`⚠️ Speed window rejected (too high): ${medianWindowSpeed.toFixed(1)} km/h (cap: ${maxSustainableSpeed})`);
                                        }
                                        if (speedupRatio > maxSpeedupRatio) {
                                            console.log(`⚠️ Speed window rejected (ratio too high): ${medianWindowSpeed.toFixed(1)} km/h (ratio: ${speedupRatio.toFixed(2)}x, max: ${maxSpeedupRatio}x)`);
                                        }
                                        
                                        if (cappedSpeed > 2 && cappedSpeed <= maxSustainableSpeed && speedupRatio <= maxSpeedupRatio) {
                                            if (cappedSpeed > maxAvgSpeed) {
                                                maxAvgSpeed = cappedSpeed;
                                                maxAvgSpeedPoints = filtered.length;
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                            j++;
                        }
                    }
                }
                
                // Only show if we found valid sustained speed within human limits
                if (maxAvgSpeed > 2 && maxAvgSpeed <= maxSustainableSpeed) {
                    const paceValue = 60 / maxAvgSpeed;
                    const paceString = (paceValue >= 2.4 && paceValue < 20 && isFinite(paceValue)) ? ` (${Utils.formatPace(paceValue)} pace)` : '';
                    
                    // DEBUG: Show comparison
                    console.log('🚀 Top Sustained Speed:');
                    console.log(`  Route median speed: ${medianSpeed.toFixed(2)} km/h`);
                    console.log(`  Top sustained speed (median): ${maxAvgSpeed.toFixed(2)} km/h`);
                    console.log(`  Speedup ratio: ${(maxAvgSpeed / medianSpeed).toFixed(2)}x`);
                    console.log(`  Based on ${maxAvgSpeedPoints} filtered points`);
                    
                    insights.push(this.createInsightCard('positive', '🚀 Top Sustained Speed', 
                        `${maxAvgSpeed.toFixed(1)} km/h`, 
                        `Peak velocity over ~${TARGET_DURATION_SECONDS} seconds${paceString}`));
                }
                
                // Surge Detection - use smoothed data with realistic limits
                const realisticSpeeds = route.speeds.filter(s => 
                    s !== null && 
                    !isNaN(s) && 
                    isFinite(s) && 
                    s > 0 && 
                    s < maxGpsThreshold
                );
                
                if (realisticSpeeds.length < 10) {
                    return insights;
                }
                
                const smoothedSpeeds = [];
                const smoothWindow = 3;
                for (let i = 0; i < realisticSpeeds.length; i++) {
                    const start = Math.max(0, i - Math.floor(smoothWindow / 2));
                    const end = Math.min(realisticSpeeds.length, i + Math.ceil(smoothWindow / 2));
                    const window = realisticSpeeds.slice(start, end);
                    smoothedSpeeds.push(window.reduce((a, b) => a + b, 0) / window.length);
                }
                
                // Detect surges
                let surges = 0;
                let inSurge = false;
                let surgeLength = 0;
                
                for (let i = 1; i < smoothedSpeeds.length; i++) {
                    if (smoothedSpeeds[i-1] > 0) {
                        const change = (smoothedSpeeds[i] - smoothedSpeeds[i-1]) / smoothedSpeeds[i-1];
                        
                        if (change > 0.3) {
                            if (!inSurge) {
                                surgeLength = 1;
                                inSurge = true;
                            } else {
                                surgeLength++;
                            }
                        } else {
                            if (inSurge && surgeLength >= 3) {
                                surges++;
                            }
                            inSurge = false;
                            surgeLength = 0;
                        }
                    }
                }
                if (inSurge && surgeLength >= 3) {
                    surges++;
                }
                
                // Only show if meaningful
                if (surges >= 3 && surges <= 50 && route.stats.distance > 0) {
                    const surgeDensity = surges / (route.stats.distance / 1000);
                    let interpretation;
                    if (surgeDensity > 1) {
                        interpretation = 'Aggressive racing - lots of position changes! 🏁';
                    } else if (surgeDensity > 0.5) {
                        interpretation = 'Multiple speed bursts detected - racing someone? 😄';
                    } else {
                        interpretation = 'Occasional speed pickups throughout the race';
                    }
                    
                    insights.push(this.createInsightCard('neutral', '⚡ Surge Count', `${surges} surges`, interpretation));
                }
                
                return insights;
            }
            
            calculateCadenceInsights(route) {
                const insights = [];
                if (!route.cadences || route.cadences.length < 10) return insights;
                
                const validCadence = route.cadences.filter(c => c !== null && !isNaN(c) && isFinite(c) && c >= 50 && c <= 250);
                if (validCadence.length < 10) return insights;
                
                const avgCadence = validCadence.reduce((a, b) => a + b, 0) / validCadence.length;
                
                // Find most efficient cadence (correlate with best pace if pace data available)
                if (route.paces && route.paces.length > 10) {
                    const validData = route.paces.map((p, i) => ({
                        pace: p,
                        cadence: route.cadences[i]
                    })).filter(d => d.pace !== null && !isNaN(d.pace) && d.pace > 0 && d.pace < 20 && 
                                     d.cadence !== null && !isNaN(d.cadence) && d.cadence >= 50 && d.cadence <= 250);
                    
                    if (validData.length > 10) {
                        const sorted = [...validData].sort((a, b) => a.pace - b.pace);
                        const topPaces = sorted.slice(0, Math.max(1, Math.floor(sorted.length * 0.1)));
                        
                        if (topPaces.length > 0) {
                            const bestCadence = topPaces.reduce((a, b) => a + b.cadence, 0) / topPaces.length;
                            
                            if (bestCadence >= 50 && bestCadence <= 250) {
                                insights.push(this.createInsightCard('positive', '👟 Optimal Cadence', `${Math.round(bestCadence)} spm`, 
                                    `Your fastest sections averaged ${Math.round(bestCadence)} steps per minute`));
                            }
                        }
                    }
                }
                
                return insights;
            }
            
            calculateQuirkyStats(route) {
                const insights = [];
                
                // Estimated steps
                if (route.stats.distance && route.stats.duration) {
                    const avgCadence = route.cadences.length > 0 ? 
                        route.cadences.filter(c => c !== null).reduce((a, b) => a + b, 0) / route.cadences.filter(c => c !== null).length : 
                        170; // Assume 170 spm if no data
                    const durationMinutes = route.stats.duration / 60;
                    const steps = Math.round(avgCadence * durationMinutes);
                    
                    insights.push(this.createInsightCard('neutral', '👣 Steps Taken', steps.toLocaleString(), 
                        'Approximate steps based on cadence'));
                }
                
                // Heartbeats
                if (route.heartRates.length > 0 && route.stats.duration) {
                    const avgHR = route.heartRates.filter(hr => hr !== null).reduce((a, b) => a + b, 0) / route.heartRates.filter(hr => hr !== null).length;
                    const durationMinutes = route.stats.duration / 60;
                    const beats = Math.round(avgHR * durationMinutes);
                    
                    insights.push(this.createInsightCard('neutral', '❤️ Heartbeats', beats.toLocaleString(), 
                        'Total heartbeats during this run'));
                }
                
                // Time of day (if timestamp available)
                if (route.timestamps.length > 0 && route.timestamps[0]) {
                    const startTime = route.timestamps[0];
                    const hour = startTime.getHours();
                    let timeOfDay, emoji;
                    
                    if (hour < 6) {
                        timeOfDay = 'Early Bird';
                        emoji = '🌙';
                    } else if (hour < 12) {
                        timeOfDay = 'Morning Warrior';
                        emoji = '🌅';
                    } else if (hour < 17) {
                        timeOfDay = 'Afternoon Runner';
                        emoji = '☀️';
                    } else if (hour < 20) {
                        timeOfDay = 'Evening Athlete';
                        emoji = '🌆';
                    } else {
                        timeOfDay = 'Night Owl';
                        emoji = '🌙';
                    }
                    
                    const timeStr = startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                    insights.push(this.createInsightCard('neutral', `${emoji} ${timeOfDay}`, timeStr, 
                        `Started at ${timeStr}`));
                }
                
                return insights;
            }
            
            createInsightCard(type, title, value, description) {
                return `
                    <div class="insight-card ${type}">
                        <div class="insight-title">${title}</div>
                        <div class="insight-value">${value}</div>
                        <div class="insight-description">${description}</div>
                    </div>
                `;
            }
            
            compareMetric(metricType) {
                const selectedRoutes = this.routes.filter(r => r.selected);
                
                const metricConfig = {
                    elevation: { data: 'elevations', name: 'Elevation', label: 'Elevation (m)', format: v => Math.round(v) + 'm' },
                    speed: { data: 'speeds', name: 'Speed', label: 'Speed (km/h)', format: v => v.toFixed(1) + ' km/h' },
                    pace: { data: 'paces', name: 'Pace', label: 'Pace (min/km)', format: v => Utils.formatPace(v) },
                    heartrate: { data: 'heartRates', name: 'Heart Rate', label: 'Heart Rate (bpm)', format: v => Math.round(v) + ' bpm' },
                    cadence: { data: 'cadences', name: 'Cadence', label: 'Cadence (spm)', format: v => Math.round(v) + ' spm' },
                    power: { data: 'powers', name: 'Power', label: 'Power (W)', format: v => Math.round(v) + 'W' }
                };
                
                const config = metricConfig[metricType];
                const validRoutes = selectedRoutes.filter(r => r[config.data] && r[config.data].length > 0);
                
                if (validRoutes.length < 2) {
                    alert(`Please select at least 2 routes with ${config.name.toLowerCase()} data`);
                    return;
                }
                
                this.chartManager.show(validRoutes, metricType, config.label, config.format);
            }
            
            updateComparison() {
                const selectedRoutes = this.routes.filter(r => r.selected);
                const panel = document.getElementById('comparisonPanel');
                
                if (selectedRoutes.length < 2) {
                    panel.classList.remove('show');
                    return;
                }
                
                // Enable/disable metric buttons
                const hasMetric = (prop) => selectedRoutes.some(r => r[prop] && r[prop].length > 0);
                document.querySelectorAll('.comparison-elevation-btn').forEach(btn => {
                    const metric = btn.dataset.metric;
                    const propMap = {
                        elevation: 'elevations',
                        speed: 'speeds',
                        pace: 'paces',
                        heartrate: 'heartRates',
                        cadence: 'cadences',
                        power: 'powers'
                    };
                    btn.disabled = !hasMetric(propMap[metric]);
                });
                
                panel.classList.add('show');
                
                // Build comparison table
                let html = `
                    <thead>
                        <tr>
                            <th>Route</th>
                            <th>Distance</th>
                            <th>Elevation Gain</th>
                            <th>Max Elevation</th>
                            <th>Duration</th>
                            <th>Avg Heart Rate</th>
                            <th>Avg Pace</th>
                            <th>Avg Cadence</th>
                        </tr>
                    </thead>
                    <tbody>
                `;
                
                selectedRoutes.forEach(route => {
                    const avg = (arr) => arr && arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : null;
                    
                    html += `
                        <tr>
                            <td>
                                <div class="route-name-cell">
                                    <div class="route-color-indicator" style="background: ${route.color}"></div>
                                    <strong>${route.displayName}</strong>
                                </div>
                            </td>
                            <td>${Utils.formatDistance(route.stats.distance)}</td>
                            <td>${Utils.formatElevation(route.stats.elevationGain)}</td>
                            <td>${Utils.formatElevation(route.stats.maxElevation)}</td>
                            <td>${Utils.formatDuration(route.stats.duration)}</td>
                            <td>${Utils.formatHeartRate(avg(route.heartRates))}</td>
                            <td>${Utils.formatPace(avg(route.paces))}</td>
                            <td>${Utils.formatCadence(avg(route.cadences))}</td>
                        </tr>
                    `;
                });
                
                html += '</tbody>';
                document.getElementById('comparisonTableContent').innerHTML = html;
            }
            
            closeComparison() {
                document.getElementById('comparisonPanel').classList.remove('show');
            }
            
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const toggle = document.getElementById('sidebarToggle');
                
                sidebar.classList.toggle('collapsed');
                toggle.textContent = sidebar.classList.contains('collapsed') ? '▶' : '◀';
                toggle.title = sidebar.classList.contains('collapsed') ? 'Show sidebar' : 'Hide sidebar';
                
                setTimeout(() => {
                    google.maps.event.trigger(this.mapManager.map, 'resize');
                    if (this.routes.length > 0) {
                        this.mapManager.fitToRoutes(this.routes);
                    }
                }, 300);
            }
            
            updateUI() {
                const fileList = document.getElementById('fileList');
                const dropZone = document.getElementById('dropZone');
                const compactDropZone = document.getElementById('compactDropZone');
                
                // Show/hide save button based on routes and auth state
                const saveBtn = document.getElementById('saveCurrentBtn');
                if (this.currentUser && this.routes.length > 0) {
                    saveBtn.classList.add('visible');
                } else {
                    saveBtn.classList.remove('visible');
                }
                
                if (this.routes.length === 0) {
                    fileList.classList.add('hidden');
                    dropZone.classList.remove('hidden');
                    compactDropZone.classList.add('hidden');
                    return;
                }
                
                fileList.classList.remove('hidden');
                dropZone.classList.add('hidden');
                compactDropZone.classList.remove('hidden');
                
                fileList.innerHTML = '';
                
                this.routes.forEach((route, index) => {
                    const item = this.createFileItem(route, index);
                    fileList.appendChild(item);
                });
            }
            
            createFileItem(route, index) {
                const item = document.createElement('div');
                item.className = 'file-item';
                if (route.selected) item.classList.add('selected');
                
                // Checkbox for compare mode
                if (this.compareMode) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'compare-checkbox';
                    checkbox.checked = route.selected;
                    item.appendChild(checkbox);
                }
                
                // Header with number and color
                const header = document.createElement('div');
                header.className = 'file-header';
                
                const number = document.createElement('div');
                number.className = 'file-number';
                number.textContent = index + 1;
                number.style.borderColor = route.color;
                number.style.color = route.color;
                
                const colorBox = document.createElement('div');
                colorBox.className = 'file-color';
                colorBox.style.background = route.color;
                
                header.appendChild(number);
                header.appendChild(colorBox);
                
                // Name container
                const nameContainer = document.createElement('div');
                nameContainer.className = 'file-name-container';
                
                const displayName = document.createElement('div');
                displayName.className = 'file-display-name';
                displayName.contentEditable = true;
                displayName.textContent = route.displayName;
                displayName.spellcheck = false;
                displayName.title = 'Click to edit display name';
                
                displayName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        displayName.blur();
                    }
                });
                
                displayName.addEventListener('click', (e) => e.stopPropagation());
                
                const originalName = document.createElement('div');
                originalName.className = 'file-original-name';
                originalName.textContent = route.filename;
                originalName.title = route.filename;
                
                nameContainer.appendChild(displayName);
                nameContainer.appendChild(originalName);
                
                // Stats
                const stats = document.createElement('div');
                stats.className = 'file-stats';
                stats.innerHTML = `
                    <div class="stat-row">
                        <span class="stat-label">Distance:</span>
                        <span class="stat-value">${Utils.formatDistance(route.stats.distance)}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Elev Gain:</span>
                        <span class="stat-value">${Utils.formatElevation(route.stats.elevationGain)}</span>
                    </div>
                    ${route.stats.duration ? `
                    <div class="stat-row">
                        <span class="stat-label">Duration:</span>
                        <span class="stat-value">${Utils.formatDuration(route.stats.duration)}</span>
                    </div>` : ''}
                `;
                
                // Actions
                const actions = document.createElement('div');
                actions.className = 'file-actions';
                
                const hasMetrics = route.elevations.length > 0 || route.speeds.length > 0 || 
                                  route.paces.length > 0 || route.heartRates.length > 0 || 
                                  route.cadences.length > 0 || route.powers.length > 0;
                
                if (hasMetrics || route.stats.duration) {
                    const insightsBtn = document.createElement('button');
                    insightsBtn.className = 'insights-btn';
                    insightsBtn.textContent = '💡 Insights';
                    insightsBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.showInsightsModal(route, index);
                    };
                    actions.appendChild(insightsBtn);
                }
                
                if (route.timestamps.some(t => t !== null)) {
                    const playBtn = document.createElement('button');
                    playBtn.className = 'file-play' + (route.isPlaying ? ' playing' : '');
                    playBtn.textContent = route.isPlaying ? '⏸️ Pause' : '▶️ Play';
                    actions.appendChild(playBtn);
                }
                
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'file-toggle' + (route.visible ? '' : ' hidden-route');
                toggleBtn.textContent = route.visible ? 'Hide' : 'Show';
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'file-remove';
                removeBtn.textContent = 'Remove';
                
                actions.appendChild(toggleBtn);
                actions.appendChild(removeBtn);
                
                // Assemble
                item.appendChild(header);
                item.appendChild(nameContainer);
                item.appendChild(stats);
                item.appendChild(actions);
                
                return item;
            }
        }

        // ============================================================================
        // INITIALIZE APPLICATION
        // ============================================================================
        
        // Make app globally accessible for saved session buttons
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new RouteOverlayApp();
            window.app = app; // Make globally accessible
        });
    </script>

    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDHN981eBYt2fLPZqx-r7iwVVasKfA-738&libraries=geometry&callback=initMap" async defer></script>
</body>
</html>